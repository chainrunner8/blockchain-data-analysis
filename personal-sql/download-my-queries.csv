ID,Name,Statement
ff7aca64-2155-4511-90f9-9f322fc021d3,pike,WITH opUSDC AS (   SELECT     origin_from_address AS signer,     amount_usd   FROM optimism.core.ez_token_transfers   WHERE 1=1     --AND tx_hash = '0x779be968e873bc308b65eee7b9184553998b746672c4a9a496354c837fd6acba'     AND (from_address = '0x7856493b59cdb1685757a6dcce12425f6a6666a0'       OR to_address = '0x7856493b59cdb1685757a6dcce12425f6a6666a0')     AND block_timestamp >= '2024-01-01'   GROUP BY 1 ), opOP AS (   SELECT     origin_from_address AS signer,     amount_usd,     symbol   FROM optimism.core.ez_token_transfers   WHERE 1=1     --AND tx_hash = '0x779be968e873bc308b65eee7b9184553998b746672c4a9a496354c837fd6acba'     AND (from_address = '0x1e65e48532f6cf9747774777f3f1f6dc6cf0d81b'       OR to_address = '0x1e65e48532f6cf9747774777f3f1f6dc6cf0d81b')     AND block_timestamp >= '2024-01-01'   GROUP BY 1 ), arbUSDC AS (   SELECT     origin_from_address AS signer,     amount_usd,     symbol   FROM arbitrum.core.ez_token_transfers   WHERE 1=1     --AND tx_hash = '0x779be968e873bc308b65eee7b9184553998b746672c4a9a496354c837fd6acba'     AND (from_address = '0x7856493b59cdb1685757a6dcce12425f6a6666a0'       OR to_address = '0x7856493b59cdb1685757a6dcce12425f6a6666a0')     AND block_timestamp >= '2024-01-01'   GROUP BY 1 ), arbARB AS (   SELECT     origin_from_address AS signer,     amount_usd,     symbol   FROM optimism.core.ez_token_transfers   WHERE 1=1     --AND tx_hash = '0x779be968e873bc308b65eee7b9184553998b746672c4a9a496354c837fd6acba'     AND (from_address = '0x1e65e48532f6cf9747774777f3f1f6dc6cf0d81b'       OR to_address = '0x1e65e48532f6cf9747774777f3f1f6dc6cf0d81b')     AND block_timestamp >= '2024-01-01'   GROUP BY 1 ), -- base USDC: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913', decimals: 6
b73adb98-1159-4b56-a49c-f8e7f589d1f2,growth-ATH,-- 0xf6e932ca12afa26665dc4dde7e27be02a7c02e50 -- arbitrum.price.ez_hourly_token_prices -- avalanche.price.ez_hourly_token_prices -- bsc.price.ez_hourly_token_prices -- base.price.ez_hourly_token_prices -- ethereum.price.ez_hourly_token_prices -- gnosis.price.ez_hourly_token_prices -- near.price.fact_prices -- optimism.price.ez_hourly_token_prices -- polygon.price.ez_hourly_token_pricesc -- solana.price.ez_token_prices_hourly -- %% GROWTH FROM LAUNCH (%) & ATH %% --EVM --SELECT --  ROUND(MAX_BY(price, hour) / MIN_BY(price, hour), 1) AS growth, --  MAX(price) AS ATH, --  ROUND(MAX(price) / MIN_BY(price, hour), 1) AS max_growth --FROM {{prices_table}} --WHERE 1=1 --  AND token_address = '{{contract_address}}' --  AND hour >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --SOLANA WITH CTE AS ( SELECT   recorded_hour,   close FROM solana.price.ez_token_prices_hourly WHERE 1=1   AND token_address = '{{contract_address}}'   AND recorded_hour >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' ) SELECT   ROUND(MAX_BY(close, recorded_hour) / MIN_BY(close, recorded_hour), 1) AS growth,   MAX(close) AS ATH,   ROUND(ATH / MIN_BY(close, recorded_hour), 1) AS max_growth FROM CTE
70eee35a-8b23-49c6-a8c5-0ae7b34edee1,swap-volume-MA,-- arbitrum.defi.ez_dex_swaps -- avalanche.defi.ez_dex_swaps -- base.defi.ez_dex_swaps -- bsc.defi.ez_dex_swaps -- ethereum.defi.ez_dex_swaps -- gnosis.defi.ez_dex_swaps -- near.defi.ez_dex_swaps -- optimism.defi.ez_dex_swaps -- polygon.defi.ez_dex_swaps -- solana.defi.fact_swaps -- 0xf6e932ca12afa26665dc4dde7e27be02a7c02e50 -- %% 6-month DAILY SWAP VOLUME & VOLUME MA %% -- EVM --SELECT --  DATE_TRUNC('day', block_timestamp) AS date, --  SUM(amount_in_usd) AS daily_vol, --  SUM(daily_vol) OVER (ORDER BY date) AS alltime_swap_volume_USD, --  AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS "7D MA", --  AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS "14D MA", --  AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 30 PRECEDING AND CURRENT ROW) AS "1M MA" --FROM {{swap_table}} --WHERE 1=1 --  AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --  AND (token_in = '{{contract_address}}' --    OR token_out = '{{contract_address}}' --  ) --GROUP BY 1 --ORDER BY 1 DESC -- SOLANA WITH BuyVol AS (   SELECT     DATE_TRUNC('day', block_timestamp) AS date,     SUM(swap_to_amount * close) AS daily_buy_vol   FROM solana.defi.fact_swaps swp   INNER JOIN solana.price.ez_token_prices_hourly prc     ON DATE_TRUNC('hour', swp.block_timestamp) = prc.recorded_hour     AND swp.swap_to_mint = prc.token_address   WHERE 1=1     AND swp.block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'     AND swap_to_mint = '{{contract_address}}'   GROUP BY 1 ), SellVol AS (   SELECT     DATE_TRUNC('day', block_timestamp) AS date,     SUM(swap_from_amount * close) AS daily_sell_vol   FROM solana.defi.fact_swaps swp   INNER JOIN solana.price.ez_token_prices_hourly prc     ON DATE_TRUNC('hour', swp.block_timestamp) = prc.recorded_hour     AND swp.swap_from_mint = prc.token_address   WHERE 1=1     AND swp.block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'     AND swap_from_mint = '{{contract_address}}'   GROUP BY 1 ) SELECT   date,   daily_buy_vol + daily_sell_vol AS daily_vol,   AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS "7D MA",   AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS "14D MA",   AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 30 PRECEDING AND CURRENT ROW) AS "1M MA" FROM BuyVol JOIN SellVol   USING(date) ORDER BY 1 DESC
0da79e3a-0485-48da-8702-3aaa655dd311,WEN_alloc,SELECT * FROM solana.price.fact_token_prices_hourly WHERE 1=1   AND symbol LIKE 'NOS'   AND recorded_hour > '2024-01-31 04:00:00'
6200762a-3c4c-4dc0-a01b-c48f2833ac2f,2024-03-03 10:51 AM,WITH opUSDC AS (   SELECT     block_timestamp AS time,     --origin_from_address AS signer,     symbol,     amount   FROM optimism.core.ez_token_transfers   WHERE 1=1     --AND tx_hash = '0x779be968e873bc308b65eee7b9184553998b746672c4a9a496354c837fd6acba'     AND (from_address = '0x7856493b59cdb1685757a6dcce12425f6a6666a0'       OR to_address = '0x7856493b59cdb1685757a6dcce12425f6a6666a0')     AND origin_from_address = '0x39354d9485b5fa4c686f1bdccf07b6919db632eb'     AND block_timestamp >= '2024-01-01' ), opOP AS (   SELECT     block_timestamp AS time,     --origin_from_address AS signer,     symbol,     amount   FROM optimism.core.ez_token_transfers   WHERE 1=1     --AND tx_hash = '0x779be968e873bc308b65eee7b9184553998b746672c4a9a496354c837fd6acba'     AND (from_address = '0x1e65e48532f6cf9747774777f3f1f6dc6cf0d81b'       AND to_address = '0x39354d9485b5fa4c686f1bdccf07b6919db632eb')     AND block_timestamp >= '2024-01-01' ), op AS ( SELECT * FROM opUSDC FULL OUTER JOIN opOP USING(time, symbol, amount) ), BaseTx AS ( SELECT   block_timestamp AS time,   --signer,   symbol,   amount FROM base.core.ez_token_transfers WHERE 1=1   AND origin_to_address = '0x706f82e9bb5b0813501714ab5974216704980e31'   AND (from_address = '0x0000000000000000000000000000000000000000'     AND to_address = '0x39354d9485b5fa4c686f1bdccf07b6919db632eb')   --AND origin_from_address =    AND block_timestamp >= '2024-01-01' ) SELECT   op.symbol AS opSymbol,   op.amount AS opAmount,   BaseTx.symbol AS bSymbol,   BaseTx.amount AS bAmount FROM op ASOF JOIN BaseTx   MATCH_CONDITION(op.time < BaseTx.time)
2cbf95b0-8c5c-4d04-aa5f-a71cf951c190,polymarket_roi_histograms,WITH condensed_order_fills AS (   SELECT     tx_hash,     timestamp,     CASE       WHEN array_contains(         'PositionSplit' :: variant,         array_agg(event_name)       ) THEN TRUE       ELSE FALSE     END AS is_pos_split,     CASE       WHEN array_contains(         'PositionsMerge' :: variant,         array_agg(event_name)       ) THEN TRUE       ELSE FALSE     END AS is_pos_merge,     CASE       WHEN (         is_pos_split         OR is_pos_merge       ) THEN array_agg(         CASE           WHEN event_name = 'OrderFilled' THEN decoded_log         END       )       ELSE array_agg(         CASE           WHEN event_name = 'OrderFilled'           AND event_index != idx_max THEN decoded_log         END       )     END AS d_logs   FROM     (       SELECT         tx_hash,         block_timestamp AS timestamp,         event_name,         event_index,         decoded_log,         max(event_index) OVER (PARTITION BY tx_hash) AS idx_max       FROM         polygon.core.ez_decoded_event_logs       WHERE         1 = 1         AND block_timestamp > sysdate() - interval '3 months'         AND contract_address IN (           '0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e',           '0xc5d563a36ae78145c45a50134d48a1215220f80a',           '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',           '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'         )         AND tx_status = 'SUCCESS'         AND event_name IN ('OrderFilled', 'PositionSplit', 'PositionsMerge') -- AND tx_hash IN ('0x47549a7d1c75bf5a400d645c8b2106e164499e0e491eeaa06c60ebe0e6831518', '0x6063f3180f08a411a509a52e32830febaed04c67676b3a6fafd37919ce0497be', '0x6b3e9390514eafcc6f5631370ebad5228c7189fe6e296008c86bb1ca715a2aa0', '0xc4973407fae2f76f081bfd32283d181ad7fe6ea7a615dbb7dcd400d50b13c973')     )   GROUP BY     1,     2 ), fact_order_fills AS (   SELECT     timestamp,     CASE       WHEN is_pos_split       OR is_pos_merge THEN array_construct(         object_construct(           'address',           d_log.value:maker :: string,           'balance_change',           CASE             WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:takerAmountFilled :: float * pow(10, -6)             ELSE - d_log.value:makerAmountFilled :: float * pow(10, -6)           END         )       )       ELSE array_construct(         object_construct(           'address',           d_log.value:maker :: string,           'balance_change',           CASE             WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:takerAmountFilled :: float * pow(10, -6)             ELSE - d_log.value:makerAmountFilled :: float * pow(10, -6)           END         ),         object_construct(           'address',           d_log.value:taker :: string,           'balance_change',           CASE             WHEN d_log.value:makerAssetId :: string = '0' THEN d_log.value:makerAmountFilled :: float * pow(10, -6)             ELSE - d_log.value:takerAmountFilled :: float * pow(10, -6)           END         )       )     END AS order_details   FROM     condensed_order_fills,     lateral flatten (input => d_logs) d_log ), -- then explode it: fact_bets AS (   SELECT     timestamp,     f.value:address AS address,     f.value:balance_change AS balance_change,     CASE       WHEN balance_change < 0 THEN 'new_bet'       ELSE 'reduce_position'     END AS transfer_type   FROM     fact_order_fills,     lateral flatten (input => order_details) f ), eligible_addresses AS (   SELECT     address,     nb_trades   FROM     (       SELECT         address,         count(*) AS nb_trades       FROM         fact_bets       GROUP BY         address     ) fb     LEFT JOIN polygon.core.ez_token_transfers tsf ON fb.address = tsf.to_address   WHERE     1 = 1     AND block_timestamp > sysdate() - interval '6 months'     AND contract_address IN (       lower('0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359'),       lower('0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174')     )     AND nb_trades BETWEEN 18     AND 2000 -- we're excluding the one-off visitors category here   GROUP BY     address,     nb_trades   HAVING     min(block_timestamp) BETWEEN sysdate() - interval '3 months'     AND sysdate() - interval '2 weeks' -- for pnl numbers to make sense, we analyse new wallets less than 3 months old. ), fact_payouts AS (   SELECT     block_timestamp AS timestamp,     decoded_log:redeemer :: string AS address,     'payout' AS transfer_type,     decoded_log:payout :: float * pow(10, -6) AS balance_change   FROM     polygon.core.ez_decoded_event_logs   WHERE     1 = 1     AND block_timestamp > sysdate() - interval '3 months'     AND contract_address IN (       '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',       '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'     )     AND event_name = 'PayoutRedemption'     AND tx_status = 'SUCCESS' ), general_fact_transfers AS (   SELECT     address,     timestamp,     nb_trades,     transfer_type,     balance_change,     sum(balance_change) OVER (       PARTITION BY address       ORDER BY         timestamp     ) AS pnl   FROM     eligible_addresses     LEFT JOIN fact_bets USING(address) FULL     OUTER JOIN (       SELECT         *       FROM         eligible_addresses         LEFT JOIN fact_payouts USING(address)     ) USING(       address,       nb_trades,       timestamp,       balance_change,       transfer_type     )   WHERE     1 = 1     AND address != '0xc5d563a36ae78145c45a50134d48a1215220f80a' ), gambler_profiles AS (   SELECT     address,     nb_trades,     sum(       CASE         WHEN balance_change < 0 THEN abs(balance_change)         ELSE 0       END     ) AS all_time_wager,     round(       max_by(pnl, timestamp) / (         CASE           WHEN all_time_wager > 0 THEN all_time_wager           ELSE NULL         END       ),       2     ) AS roi,     CASE       WHEN nb_trades BETWEEN 18       AND 92 THEN 'weekly gambler'       WHEN nb_trades BETWEEN 93       AND 460 THEN 'daily gambler'       WHEN nb_trades BETWEEN 461       AND 2000 THEN 'HF gambler'     END AS gambler_profile   FROM     general_fact_transfers   GROUP BY     address,     nb_trades ) SELECT   roi,   count(     CASE       WHEN gambler_profile = 'weekly gambler' THEN 1     END   ) AS weekly_gamblers,   count(     CASE       WHEN gambler_profile = 'daily gambler' THEN 1     END   ) AS daily_gamblers,   count(     CASE       WHEN gambler_profile = 'HF gambler' THEN 1     END   ) AS HF_gamblers FROM   gambler_profiles WHERE   1 = 1   AND roi <= 10   AND all_time_wager >= 100 GROUP BY   roi ORDER BY   roi
ac4f602d-a043-4dff-ae79-ed4320d49318,polymarket_markets_traded,WITH condensed_order_fills AS (   SELECT     tx_hash,     timestamp,     CASE       WHEN array_contains(         'PositionSplit' :: variant,         array_agg(event_name)       ) THEN TRUE       ELSE FALSE     END AS is_pos_split,     CASE       WHEN array_contains(         'PositionsMerge' :: variant,         array_agg(event_name)       ) THEN TRUE       ELSE FALSE     END AS is_pos_merge,     CASE       WHEN (         is_pos_split         OR is_pos_merge       ) THEN array_agg(         CASE           WHEN event_name = 'OrderFilled' THEN decoded_log         END       )       ELSE array_agg(         CASE           WHEN event_name = 'OrderFilled'           AND event_index != idx_max THEN decoded_log         END       )     END AS d_logs   FROM     (       SELECT         tx_hash,         block_timestamp AS timestamp,         event_name,         event_index,         decoded_log,         max(event_index) OVER (PARTITION BY tx_hash) AS idx_max       FROM         polygon.core.ez_decoded_event_logs       WHERE         1 = 1         AND block_timestamp > sysdate() - interval '3 months'         AND contract_address IN (           '0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e',           '0xc5d563a36ae78145c45a50134d48a1215220f80a',           '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',           '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'         )         AND tx_status = 'SUCCESS'         AND event_name IN ('OrderFilled', 'PositionSplit', 'PositionsMerge') -- AND tx_hash IN ('0x47549a7d1c75bf5a400d645c8b2106e164499e0e491eeaa06c60ebe0e6831518', '0x6063f3180f08a411a509a52e32830febaed04c67676b3a6fafd37919ce0497be', '0x6b3e9390514eafcc6f5631370ebad5228c7189fe6e296008c86bb1ca715a2aa0', '0xc4973407fae2f76f081bfd32283d181ad7fe6ea7a615dbb7dcd400d50b13c973')     )   GROUP BY     1,     2 ), fact_order_fills AS (   SELECT     CASE       WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:makerAssetId :: string       ELSE d_log.value:takerAssetId :: string     END AS market_id,     CASE       WHEN is_pos_split OR is_pos_merge       THEN          array_construct(           object_construct(             'address',             d_log.value:maker :: string           )         )       ELSE         array_construct(           object_construct(             'address',             d_log.value:maker :: string           ),           object_construct(             'address',             d_log.value:taker :: string           )         )        END AS order_addresses   FROM     condensed_order_fills,     lateral flatten (input => d_logs) d_log ), -- then explode it: fact_bets AS (   SELECT     f.value:address AS address,     market_id   FROM     fact_order_fills,     lateral flatten (input => order_addresses) f ), eligible_addresses AS (   SELECT     address   FROM     (       SELECT         address,         COUNT(*) AS nb_trades       FROM         fact_bets       GROUP BY         address     ) fb     LEFT JOIN polygon.core.ez_token_transfers tsf ON fb.address = tsf.to_address   WHERE     1 = 1     AND block_timestamp > sysdate() - interval '6 months'     AND contract_address IN (       lower('0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359'),       lower('0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174')     )     AND nb_trades BETWEEN 18     AND 2000 -- we're excluding the one-off visitors category here   GROUP BY     address,     nb_trades   HAVING     min(block_timestamp) BETWEEN sysdate() - interval '3 months'     AND sysdate() - interval '2 weeks' -- for pnl numbers to make sense, we analyse new wallets less than 3 months old. ), general_fact_transfers AS (   SELECT     address,     market_id   FROM     eligible_addresses     LEFT JOIN fact_bets USING(address)   WHERE     1 = 1     AND address != '0xc5d563a36ae78145c45a50134d48a1215220f80a'     AND address != '0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e' ), gambler_profiles AS (   SELECT     address,     count(       DISTINCT CASE         WHEN market_id IS NOT NULL THEN market_id       END     ) AS nb_markets_traded   FROM     general_fact_transfers   GROUP BY     address ) SELECT   nb_markets_traded AS "total markets traded",   count(*) AS "gamblers" FROM   gambler_profiles WHERE   1 = 1   AND nb_markets_traded <= 111 GROUP BY   nb_markets_traded
adff21a6-dc77-45f4-ad74-fa6da64b8d3f,Getting Started,-- Get started with Flipside by running your first query: -- the SQL statement below will get you a list of NFT -- platforms on Ethereum, ranked by how many sales  -- they've had in the past month. -- Be sure to see our documentation for more guidance, -- including a full walkthrough of the app: -- https://docs.flipsidecrypto.com/our-app/getting-started select   platform_name,   count(*) as sales_count from ethereum.core.ez_nft_sales where block_timestamp > current_date - interval '30 days' group by platform_name order by sales_count desc limit 8
c8f78aba-543f-4d23-8398-5ef0455c6f5b,JUP_bridge-vol,--SELECT --  signers, --  event_type, --  instruction --FROM solana.core.fact_events --WHERE program_id = 'JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4' --  AND succeeded --  AND block_timestamp > '2024-01-26 15:01:00' WITH Bridged AS ( SELECT   DATE_TRUNC('hour', block_timestamp) AS hour,   user_address,   CASE       WHEN (  --USDX            mint = 'C321jHPwWBzgfSGndosDTp5pBsiXPyMU1irxKLVcedRB'         OR mint = '5goWRao6a3yNC4d6UjMdQxonkCMvKBwdpubU3qhfcdf1'         OR mint = 'FCqfQSujuPxy6V42UvafBhsysWtEq1vhjfMN1PUbgaxA'         OR mint = 'EfqRM8ZGWhDTKJ7BHmFvNagKVu3AxQRDQs8WMMaoBCu6'         OR mint = 'J8kcD4Wnd1ehne1dpL8WNtgZQR6Jpui2cTZcrmg5ybAa'         OR mint = 'CR4xnGrhsu1fWNPoX4KbTUUtqGMF3mzRLfj4S6YEs1Yo'         OR mint = 'A5DL346yiS2EQPjxQamxT73sHhadrPHXLSVuncetq1Sk'         OR mint = 'D8xDmP3wUJ4iRk5MS9K2bsWyUUAVNSmMDsDoVwkYuH8m'         OR mint = 'Kz1csQA91WUGcQ2TB3o5kdGmWmMGp8eJcDEyHzNDVCX'         OR mint = '8qJSyQprMC57TWKaYEmetUR3UUiTP2M3hXdcvFhkZdmv'         OR mint = '5RpUwQ8wtdPCZHhu6MERp2RGrpobsbZ6MH5dDHkUjs2'         OR mint = 'E2VmbootbVCBkMNNxKQgCLMS1X3NoGMaYAsufaAsf7M'         OR mint = 'H9o3LaDfoMSVLm9aBWaY56eMmPGDbRFnUHpqcTb9exXB'         OR mint = 'FHfba3ov5P3RjaiLVgh8FTv4oirxQDoVXuoUUDvHuXax'       )          THEN 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'       WHEN (  --WETH            mint = 'AaAEw2VCw1XzgvKB8Rj2DyK2ZVau9fbt2bE8hZFWsMyE'         OR mint = 'DQyeU3oFezEGia761GQ4iPcMCnxnH8fuLrmHZUvTYuby'         OR mint = 'DWXe1hxpnb8LAH21iyXcjvMbiAGzoYyuCVQtRLvZdLYd'       )          THEN 'CSD6JQMvLi46psjHdpfFdr826mF336pEVMJgjwcoS1m4'       WHEN mint = '25rXTx9zDZcHyTav5sRqM6YBvTGu9pPH9yv83uAEqbgG' THEN '6DNSN2BJsaPFdFFc1zP37kkeNe4Usc1Sqkzr9C9vPWcU'  --BTC       WHEN mint = 'FL288umTU1x4AJz5rgxJUF558JudWjfpEddgzWZFgmNA' THEN 'rndrizKT3MK1iimdxRdWabcF7Zg7AR5T4nud4EkHBof'  --Render       --       ELSE mint   END AS token_address,   amount FROM solana.defi.fact_bridge_activity WHERE 1=1   AND (block_timestamp > '2024-01-25 15:00:00')-- AND (block_timestamp < '2024-01-29 15:00:00')   AND succeeded   AND direction = 'inbound' ) SELECT   bdg.hour AS hour,   COUNT(DISTINCT user_address) AS bridgers,   ROUND(SUM(amount * close)) AS "bridged amount" FROM (   SELECT     hour,     user_address,     UPPER(symbol) AS symbol,     amount   FROM Bridged   LEFT JOIN solana.core.dim_tokens     USING(token_address) ) bdg JOIN solana.price.fact_token_prices_hourly prc   ON bdg.hour = prc.recorded_hour   AND bdg.symbol = prc.symbol GROUP BY 1 ORDER BY 1
560acf6d-1c5c-4701-84a6-dbbdba682726,2024-04-04 04:21 PM,--SELECT --  MIN(hour), --  MIN_BY(price, hour) --FROM crosschain.price.ez_hourly_token_prices --WHERE 1=1 --  AND blockchain = 'solana' --  AND token_address = LOWER('KMNo3nJsBXfcpJTVhZcXLW7RmTwTt4GVFE7suUBo9sS') --  AND hour >= '2024-04-29'  SELECT   MIN(hour) FROM solana.price.ez_prices_hourly WHERE token_address = 'DriFtupJYLTosbwoN8koMbEYSx54aFAVLddWsbksjwg7'
6279962b-0aa0-4782-aaeb-599b10c54962,PARCLv3_HOA,-- HOA holders are found based on lastest sale on an NFT marketplace for every mint + those -- that have never been traded on a marketplace since mint. -- Basic NFT transfers (from solana.core.fact_transfers) were not included, since that kind -- of transfer is usually the same person sending their NFT to another wallet of theirs -- (I guess there aren't many people out there who transfer NFTs to another distinct person for free). WITH    HoaTxns AS (     SELECT        mint,       block_timestamp,       purchaser,       sales_amount,       ROW_NUMBER() OVER (PARTITION BY mint ORDER BY block_timestamp DESC) AS rank     FROM solana.nft.dim_nft_metadata     INNER JOIN solana.nft.fact_nft_sales USING(mint)     WHERE collection_id = 'JBPDtrS6KqRGt5QSRDknknwyMjqzRvZQYsVuE3CMtaNt'   ),         TradedHoa AS (     SELECT       mint,       purchaser,       sales_amount     FROM HoaTxns     WHERE rank = 1   ),         HoaMint AS (     SELECT       mint,       fact_transactions.signers[0] AS minter,       mint_amount     FROM solana.nft.dim_nft_metadata     INNER JOIN solana.nft.fact_nft_mint_actions USING(mint)     INNER JOIN solana.core.fact_transactions USING(block_timestamp, tx_id)      WHERE collection_id = 'JBPDtrS6KqRGt5QSRDknknwyMjqzRvZQYsVuE3CMtaNt'     AND block_timestamp < '2023-01-01'   ),   Holders AS (     SELECT       holder,       COUNT(mint) AS nfts,       ROUND(SUM(buy_price) / nfts, 2) AS avg_buy_price_SOL     FROM (       SELECT          mint,         CASE WHEN purchaser IS NULL THEN minter ELSE purchaser END AS holder,         CASE WHEN sales_amount IS NULL THEN 0.4 ELSE sales_amount END AS buy_price  -- mint price was 0.4 SOL       FROM TradedHoa       RIGHT OUTER JOIN HoaMint USING(mint)     )     GROUP BY holder   ),   NftBins AS (     SELECT       holder,       nfts,       CASE         WHEN nfts = 1 THEN '1'         WHEN nfts = 2 THEN '2'         WHEN nfts = 3 THEN '3'         WHEN nfts = 4 THEN '4'         WHEN nfts = 5 THEN '5'         WHEN nfts = 6 THEN '6'         WHEN nfts = 7 THEN '7'         WHEN nfts = 8 THEN '8'         WHEN nfts = 9 THEN '9'         WHEN nfts BETWEEN 10 AND 15 THEN '10 - 15'         WHEN nfts BETWEEN 16 AND 24 THEN '16 - 24'          WHEN nfts BETWEEN 25 AND 50 THEN '25 - 50'         WHEN nfts BETWEEN 51 AND 100 THEN '51 - 100'         WHEN nfts > 100 THEN '> 100'       END AS nft_bin,       avg_buy_price_SOL     FROM Holders   ) SELECT   nft_bin,   COUNT(holder) AS holders,   MAX(nfts) AS max_nfts,   MAX(avg_buy_price_SOL) AS max_avg_buy_price_SOL FROM NftBins GROUP BY nft_bin ORDER BY max_nfts
5249c224-0595-4d87-bba4-953f9b256162,Deans list learn (NFT Sales),with table1 as (     select DISTINCT address     from solana.core.dim_labels     where address_name = 'claynosaurz' ) SELECT   marketplace,   CASE      when sales_amount <= 30 then 'a/ Below 30 SOL'     when sales_amount between 30 and 35 then 'b/ 30 - 35 SOL'     when sales_amount between 35 and 40 then 'b/ 35 - 40 SOL'     when sales_amount >= 40 then 'c/ Over 40 SOL'   end as sale_group,   count(*) as sales,   sum(sales_amount) as sales_volume FROM solana.nft.fact_nft_sales WHERE SUCCEEDED = TRUE and mint in (SELECT address from table1) AND block_timestamp > current_date - 30 --AND marketplace = 'tensorswap' GROUP by sale_group, marketplace
05299917-1568-483a-95af-216e56e0d5a2,Deans list learn (Dex Swaps),SELECT    --date(block_timestamp) as day,   swap_program,   count(DISTINCT swapper) as swappers  FROM solana.defi.fact_swaps WHERE (swap_to_mint LIKE 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263' OR swap_from_mint LIKE 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263') AND block_timestamp > current_date - 30 GROUP by swap_program
fa5a4e5f-d048-481e-aad4-7f1a71c8622a,Deans list learn (Transfers),SELECT   date_trunc('day', block_timestamp) as day,   --tx_to,   max(AMOUNT) as largest_transfer,   min(AMOUNT) as smallest_transfer,   count(DISTINCT tx_id) as transactions,   count(DISTINCT TX_FROM) as senders,   sum(AMOUNT) as transfer_volume    FROM solana.core.fact_transfers WHERE true = true and mint = 'Ds52CDgqdWbTWsua1hgT3AuSSy4FNx2Ezge1br3jQ14a' --and tx_from = '[from_address]' and tx_to = '8mR9JwadNcpRtZXYAH711wh6SobFN4jWyAkQW8KZw6PE' and block_timestamp between '2023-11-01' and current_date - 1 --and add any other logic statement using columns from the table  group by day  --group by tx_to
bf2f83b8-87c4-4d72-8909-a51060b7ee25,sollinked-attempt,SELECT   DATE_TRUNC('day', block_timestamp) AS day,   COUNT(tx_id) FROM solana.core.fact_transactions WHERE block_timestamp >= '2023-12-01'   AND signers[0] = 'GZmKJekTsJWzEZ7dphVfx238eP1gzNt4U5Aqb9qMXd5a'   AND account_keys[8]:pubkey = 'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY'   AND succeeded GROUP BY 1
72d5d447-0888-4803-b6a9-8aadf7ea038d,PARCLv3_cumul-unique-users,SELECT COUNT(DISTINCT(signers[0])) AS cumulative_unique_users FROM solana.core.fact_events JOIN solana.core.fact_transactions using(block_timestamp, block_id, tx_id) WHERE program_id = '3parcLrT7WnXAcyPfkCz49oofuuf2guUKkjuFkAhZW8Y'   AND block_timestamp >= '2023-11-14'   AND succeeded
1f912a9e-63c7-4291-89f3-600b4c2f8a66,PARCLv3_trades-markets,WITH   Trades AS (     SELECT       DISTINCT       block_timestamp,       tx_id,       signers[0] AS signer,       account_keys     FROM solana.core.fact_transactions     JOIN solana.core.fact_events USING(block_timestamp, tx_id, signers)     WHERE program_id = '3parcLrT7WnXAcyPfkCz49oofuuf2guUKkjuFkAhZW8Y'       -- "ModifyPosition" ix is called whenever a trade is made (modifying an open postion or opening new/closing entire position).       AND ARRAY_CONTAINS('Program log: Instruction: ModifyPosition'::variant, log_messages)       AND block_timestamp >= '2023-11-14'       AND succeeded   )   -- Market share section needs to be improved, only an approximation right now.   -- Every time a trade is made and ModifyPosition is called, all the market accounts in which the trader has open positions   -- are marked "Writable". The issue is, when there are several of them, I haven't found a way to tell which market the trade   -- whose transaction I'm looking at was made on. Say if NY and Austin were both "Writable" in the trader's previous trade tx and   -- also are in this tx, which market did they trade on this time? SELECT   DATE_TRUNC('week', block_timestamp) AS week,   COUNT(DISTINCT signer) AS total_active_traders,   COUNT(DISTINCT tx_id) AS trades,                  SUM(trades) OVER (ORDER BY week) AS cumulative_trades,   SUM(CASE WHEN acc_keys.value:pubkey = '8QLQf9mA9CC823KXyLRpLCpGbkDSkS4AdSv8LBoMfXjN' AND acc_keys.value:writable::BOOLEAN = TRUE THEN 1 END) AS new_york_trades,   SUM(CASE WHEN acc_keys.value:pubkey = '2qJt3MWwGQQ9AcbdrWQ9mhth6TVfgQ9vUAbtrMWFZ78T' AND acc_keys.value:writable::BOOLEAN = TRUE THEN 1 END) AS miami_beach_trades,   SUM(CASE WHEN acc_keys.value:pubkey = 'GqpMnTPsVX3t8fxDSdQE6mgc8FTJBiL1z4s4o5mMJDhU' AND acc_keys.value:writable::BOOLEAN = TRUE THEN 1 END) AS san_fransisco_trades,   SUM(CASE WHEN acc_keys.value:pubkey = 'F3oMGAuWNRCTXEtUQehn87ziYVhSPwAySjMrQrFJapMj' AND acc_keys.value:writable::BOOLEAN = TRUE THEN 1 END) AS austin_trades,   SUM(CASE WHEN acc_keys.value:pubkey = 'FkvSvtDcWTKNYSbk1m74CCpKbKKnPVUFsy7U5cWYxmU3' AND acc_keys.value:writable::BOOLEAN = TRUE THEN 1 END) AS las_vegas_trades,   SUM(CASE WHEN acc_keys.value:pubkey = '7UHPEqFRVgyYtjXuXdL3hxwP8NMBQoeSxBSy23xoKrnG' AND acc_keys.value:writable::BOOLEAN = TRUE THEN 1 END) AS brooklyn_trades FROM Trades,   LATERAL FLATTEN (input => account_keys) acc_keys GROUP BY week ORDER BY week
1610b393-3598-4c40-8fd7-868c6ae673a7,PARCLv3_user-metrics,WITH       Transfers AS (     SELECT       block_timestamp,       tx_id,       signers[0] AS signer,       tx_from,       tx_to,       amount, --             Below we identify the nature of money flows in and out Exchange 1 based on the name of the ix called.       ARRAY_CONTAINS('Program log: Instruction: AddLiquidity'::variant, log_messages) AS is_lp_deposit, -- depositing to the LP uses the AddLiquidity ix       ARRAY_CONTAINS('Program log: Instruction: ProcessSettlementRequests'::variant, log_messages) AS is_withdrawal -- withdrawing margin uses ProcessSettlementRequests ix     FROM solana.core.fact_transfers     JOIN solana.core.fact_transactions USING(block_timestamp, tx_id)     WHERE (tx_from = '82dGS7Jt4Km8ZgwZVRsJ2V6vPXEhVdgDaMP7cqPGG1TW' -- this is the Exchange 1 address that every tx (margin/liquidity deposit or withdrawal) goes through.         OR tx_to = '82dGS7Jt4Km8ZgwZVRsJ2V6vPXEhVdgDaMP7cqPGG1TW')       AND (ARRAY_CONTAINS('Program log: Instruction: DepositMargin'::variant, log_messages)         OR ARRAY_CONTAINS('Program log: Instruction: AddLiquidity'::variant, log_messages)         OR ARRAY_CONTAINS('Program log: Instruction: ProcessSettlementRequests'::variant, log_messages)       )       AND block_timestamp >= '2023-11-14'       AND succeeded   ),         TradesLiqRemv AS (     SELECT       DISTINCT       block_timestamp,       tx_id,       signers[0] AS signer,       account_keys,       ARRAY_CONTAINS('Program log: Instruction: ModifyPosition'::variant, log_messages) AS is_trade,       ARRAY_CONTAINS('Program log: Instruction: RemoveLiquidity'::variant, log_messages) AS is_lp_withdrawal     FROM solana.core.fact_transactions     JOIN solana.core.fact_events USING(block_timestamp, tx_id, signers)     WHERE program_id = '3parcLrT7WnXAcyPfkCz49oofuuf2guUKkjuFkAhZW8Y'       -- "ModifyPosition" ix is called whenever a trade is made (modifying an open postion or opening new/closing entire position).       AND (ARRAY_CONTAINS('Program log: Instruction: ModifyPosition'::variant, log_messages)       -- removing funds from LP uses RemoveLiquidity ix         OR ARRAY_CONTAINS('Program log: Instruction: RemoveLiquidity'::variant, log_messages)       )       AND block_timestamp >= '2023-11-14'       AND succeeded   ),   -- Weeks during which each trader has traded to this day   TradingWeeks AS (     SELECT       signer,       ARRAY_AGG(DISTINCT DATE(DATE_TRUNC('week', block_timestamp))) AS weeks     FROM TradesLiqRemv     WHERE is_trade     GROUP BY signer   ),   -- Unlike trading, providing liquidity is a continuous process with start & end dates, which was slightly harder to track.    LiqRemoved AS (     SELECT       tsf.block_timestamp AS block_timestamp,       tsf.tx_id AS tx_id,       tsf.signer AS signer,       tsf.tx_to AS tx_to,       amount,       TRUE AS is_lp_withdrawal     FROM TradesLiqRemv liq     INNER JOIN Transfers tsf ON tsf.tx_to = liq.signer     WHERE liq.is_lp_withdrawal       AND tsf.is_withdrawal       AND tsf.tx_from = '82dGS7Jt4Km8ZgwZVRsJ2V6vPXEhVdgDaMP7cqPGG1TW'       -- The ProcessSettlementRequests transaction happens 24 hours later, usually within a 15-minute window:       AND tsf.block_timestamp BETWEEN DATEADD('day', +1 , liq.block_timestamp) AND DATEADD('minute', +15, DATEADD('day', +1 , liq.block_timestamp))   ),      -- Here I'm making the assumption that if a user has withdrawn 95% (if negative LP PnL) or more (with accrued LP fees) liquidity    -- than they've ever deposited, they are not providing liquidity anymore (or it's negligible). In that event, the date of the   -- last withdrawal tx is considered the date they stopped being an LP. So, like for the market shares, it's an approximation.   LpActivity AS (     SELECT       signer,       SUM(CASE WHEN tsf.is_lp_deposit THEN amount END) AS liq_deposits,       SUM(CASE WHEN liq.is_lp_withdrawal THEN amount END) AS liq_withdrawals,       CASE WHEN liq_withdrawals >= (liq_deposits * 0.95) THEN 'not LP' ELSE 'LP' END AS is_lp,       DATE_TRUNC('week', MIN(block_timestamp)) AS first_deposit,       CASE WHEN is_lp = 'not LP' THEN MAX(block_timestamp) ELSE DATEADD(DAY, +1, CURRENT_DATE) END AS last_withdrawal     FROM Transfers tsf     LEFT JOIN LiqRemoved liq USING(block_timestamp, tx_id, signer, tx_to, amount)     WHERE (tsf.is_lp_deposit OR liq.is_lp_withdrawal)     GROUP BY signer   ),         UserActivity AS (     SELECT       COALESCE(first_deposit, '2000-01-01') AS lp_start,       COALESCE(last_withdrawal, '2000-01-01') AS lp_stop,       COALESCE(weeks, ARRAY_CONSTRUCT()) AS trading_weeks     FROM LpActivity     FULL OUTER JOIN TradingWeeks USING(signer)   ),         -- And here I go through every week since v3 kickoff and check if every historically recorded LP had started/kept/stopped   -- providing liquidity, and/or traded on that week, and that effectively gives me the number of active LPs & traders every week:   UserTypes AS (     SELECT        week,       COUNT(CASE WHEN (week BETWEEN lp_start AND lp_stop) AND NOT ARRAY_CONTAINS(DATE(week)::variant, trading_weeks) THEN 1 END) AS pure_LPs,       COUNT(CASE WHEN (week NOT BETWEEN lp_start AND lp_stop) AND ARRAY_CONTAINS(DATE(week)::variant, trading_weeks) THEN 1 END) AS pure_traders,       COUNT(CASE WHEN (week BETWEEN lp_start AND lp_stop)     AND ARRAY_CONTAINS(DATE(week)::variant, trading_weeks) THEN 1 END) AS both_trader_and_LP,       pure_LPs + both_trader_and_LP AS active_LPs,       pure_traders + both_trader_and_LP AS active_traders     FROM UserActivity     CROSS JOIN (       SELECT DISTINCT first_deposit AS week       FROM LpActivity     )     GROUP BY week   ),   -- active users (unique signers for all activities on the platform)   Wau AS (     SELECT        week,       COUNT(DISTINCT signer) AS wau     FROM (       SELECT          signer,          DATE_TRUNC('week', block_timestamp) AS week       FROM Transfers       FULL OUTER JOIN TradesLiqRemv USING(signer, block_timestamp)     )     GROUP BY week   ) SELECT * FROM Wau JOIN UserTypes USING(week)
051de7c2-d50f-4ee5-ab7f-e3a2696887a8,coin-native-growth,-- BASE WETH: 0x4200000000000000000000000000000000000006 -- ARB ARB: 0x912CE59144191C1204E64559FE8253a0e49E6548 -- AVA WAVAX: 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7 -- BSC WBNB: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c -- ETH WETH: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 -- GNOS GNOSIS: 0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb -- NEAR WNEAR: wrap.near -- OP OP: 0x4200000000000000000000000000000000000042 -- POLY MATIC: 0x0000000000000000000000000000000000001010 -- SOL WSOL: So11111111111111111111111111111111111111112 -- arbitrum.price.ez_hourly_token_prices -- avalanche.price.ez_hourly_token_prices -- bsc.price.ez_hourly_token_prices -- base.price.ez_hourly_token_prices -- ethereum.price.ez_hourly_token_prices -- gnosis.price.ez_hourly_token_prices -- near.price.fact_prices -- optimism.price.ez_hourly_token_prices -- polygon.price.ez_hourly_token_prices -- solana.price.ez_token_prices_hourly -- %% COIN VS NATIVE CURRENCY GROWTH (%) %% --  EVM --WITH Native AS ( --  SELECT --    DATE_TRUNC('day', hour) AS date, --    MAX_BY(price, hour) AS native_close --  FROM {{prices_table}} --  WHERE 1=1 --    AND hour >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --    AND token_address = '{{native_address}}' --  GROUP BY 1 --), -- --Coin AS ( --  SELECT --    DATE_TRUNC('day', hour) AS date, --    MAX_BY(price, hour) AS coin_close --  FROM {{prices_table}} --  WHERE 1=1 --    AND hour >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --    AND token_address = '{{contract_address}}' --  GROUP BY 1 --), -- --GenesisNative AS ( --  SELECT --    MIN_BY(native_close, date) AS gen_native --  FROM Native --), -- --GenesisCoin AS ( --  SELECT --    MIN_BY(coin_close, date) AS gen_coin --  FROM Coin --), -- --NativeGrowth AS ( --  SELECT --    date, --    native_close, --    100 * (native_close - gen_native) / gen_native AS native_growth --  FROM Native, GenesisNative --), -- --CoinGrowth AS ( --  SELECT --    date, --    coin_close, --    100 * (coin_close - gen_coin) / gen_coin AS coin_growth --  FROM Coin, GenesisCoin --) -- --SELECT *, --  CASE WHEN native_growth <> 0 THEN ROUND(coin_growth / native_growth, 1) ELSE 1 END AS perf_ratio --FROM NativeGrowth --JOIN CoinGrowth USING(date) --ORDER BY 1 DESC --SOLANA WITH Native AS (   SELECT     DATE_TRUNC('day', recorded_hour) AS date,     MAX_BY(close, recorded_hour) AS native_close   FROM solana.price.ez_token_prices_hourly   WHERE 1=1     AND recorded_hour >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'     AND token_address = 'So11111111111111111111111111111111111111112'   GROUP BY 1 ), Coin AS (   SELECT     DATE_TRUNC('day', recorded_hour) AS date,     MAX_BY(close, recorded_hour) AS coin_close   FROM solana.price.ez_token_prices_hourly   WHERE 1=1     AND recorded_hour >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'     AND token_address = '{{contract_address}}'   GROUP BY 1 ), GenesisNative AS (   SELECT     MIN_BY(native_close, date) AS gen_native   FROM Native ), GenesisCoin AS (   SELECT     MIN_BY(coin_close, date) AS gen_coin   FROM Coin ), NativeGrowth AS (   SELECT     date,     native_close,     100 * (native_close - gen_native) / gen_native AS SOL_growth   FROM Native, GenesisNative ), CoinGrowth AS (   SELECT     date,     coin_close,     100 * (coin_close - gen_coin) / gen_coin AS WEN_growth   FROM Coin, GenesisCoin ) SELECT *,   CASE WHEN SOL_growth <> 0 THEN ROUND(100 * (1 + WEN_growth) / (1 + SOL_growth)) ELSE 1 END AS perf_ratio FROM NativeGrowth JOIN CoinGrowth USING(date) ORDER BY 1 DESC
4c3f587d-edfb-4194-aab6-b97e96c736a7,unique-swappers,-- 0xf6e932ca12afa26665dc4dde7e27be02a7c02e50 -- arbitrum.defi.ez_dex_swaps -- avalanche.defi.ez_dex_swaps -- base.defi.ez_dex_swaps -- bsc.defi.ez_dex_swaps -- ethereum.defi.ez_dex_swaps -- gnosis.defi.ez_dex_swaps -- near.defi.ez_dex_swaps -- optimism.defi.ez_dex_swaps -- polygon.defi.ez_dex_swaps -- solana.defi.fact_swaps -- %% 6-month UNIQUE SWAPPERS %% --EVM --SELECT --  COUNT(DISTINCT origin_from_address) AS swappers --FROM {{swap_table}} --WHERE 1=1 --  AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --  AND (token_in = '{{contract_address}}' --    OR token_out = '{{contract_address}}' --  ) --SOLANA SELECT   COUNT(DISTINCT swapper) AS swappers FROM solana.defi.fact_swaps WHERE 1=1   AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'   AND (swap_from_mint = '{{contract_address}}'     OR swap_to_mint = '{{contract_address}}'   )
31ea5b3d-b870-4486-ab1d-fa05021a0614,Base tokens,-- Ondo (eth): 0xfaba6f8e4a5e8ab82f62fe7c39859fa577269be3 -- Pendle (eth): 0x808507121b80c02388fad14726482e061b8da827 -- Mantra (eth): 0x3593d125a4f7849a1b059e64f4517a86dd60c95d -- Chex (eth): 0x9ce84f6a69986a83d92c324df10bc8e64771030f -- Goldfinch (eth): 0xdab396ccf3d84cf2d07c4454e10c8a6f5b008d2b WITH OClose AS (   SELECT     hour,     price   FROM ethereum.price.ez_hourly_token_prices   WHERE 1=1     AND token_address = '0xfaba6f8e4a5e8ab82f62fe7c39859fa577269be3'     AND hour >= '2024-01-20' ), OMin AS (   SELECT     MIN_BY(price, hour) AS o_min   FROM OClose ), Ondo AS (   SELECT     hour,     100 * price / o_min AS ondo_growth   FROM OClose, OMin ), PClose AS (   SELECT     hour,     price   FROM ethereum.price.ez_hourly_token_prices   WHERE 1=1     AND token_address = '0x808507121b80c02388fad14726482e061b8da827'     AND hour >= '2024-01-20' ), PMin AS (   SELECT     MIN_BY(price, hour) AS p_min   FROM PClose ), Pendle AS (   SELECT     hour,     100 * price / p_min AS pendle_growth   FROM PClose, PMin ), MClose AS (   SELECT     hour,     price   FROM ethereum.price.ez_hourly_token_prices   WHERE 1=1     AND token_address = '0x3593d125a4f7849a1b059e64f4517a86dd60c95d'     AND hour >= '2024-01-20' ), MMin AS (   SELECT     MIN_BY(price, hour) AS m_min   FROM MClose ), Mantra AS (   SELECT     hour,     100 * price / m_min AS mantra_growth   FROM MClose, MMin ), CClose AS (   SELECT     hour,     price   FROM ethereum.price.ez_hourly_token_prices   WHERE 1=1     AND token_address = '0x9ce84f6a69986a83d92c324df10bc8e64771030f'     AND hour >= '2024-01-20' ), CMin AS (   SELECT     MIN_BY(price, hour) AS c_min   FROM CClose ), Chex AS (   SELECT     hour,     100 * price / c_min AS chex_growth   FROM CClose, CMin ), GClose AS (   SELECT     hour,     price   FROM ethereum.price.ez_hourly_token_prices   WHERE 1=1     AND token_address = '0xdab396ccf3d84cf2d07c4454e10c8a6f5b008d2b'     AND hour >= '2024-01-20' ), GMin AS (   SELECT     MIN_BY(price, hour) AS g_min   FROM GClose ), Gold AS (   SELECT     hour,     100 * price / g_min AS gold_growth   FROM GClose, GMin ) SELECT   hour,   ondo_growth,   pendle_growth,   mantra_growth,   chex_growth,   gold_growth FROM Ondo LEFT JOIN Pendle USING(hour) LEFT JOIN Mantra USING(hour) LEFT JOIN Chex USING(hour) LEFT JOIN Gold USING(hour) ORDER BY 1
79281f40-1eef-486d-98b6-da9dca0e6ccf,PARCLv3_weekly-HOA,SELECT    DATE_TRUNC('week', block_timestamp) AS week,   ROUND(SUM(sales_amount)) AS weekly_volume_SOL,   SUM(weekly_volume_SOL) OVER (ORDER BY week) AS cumulative_vol FROM solana.nft.dim_nft_metadata INNER JOIN solana.nft.fact_nft_sales USING(mint) WHERE collection_id = 'JBPDtrS6KqRGt5QSRDknknwyMjqzRvZQYsVuE3CMtaNt' AND succeeded GROUP BY week ORDER BY week DESC
8f45cf38-ac2f-4cf1-ba0c-450eaa1ecc8a,normilio,--WITH Receivers AS ( --  SELECT --    to_address AS addy, --    SUM(amount_precise) AS received_amount --  FROM {{transfers_table}} --  WHERE 1=1 --    AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --    AND contract_address = '{{contract_address}}' --    AND amount_usd > 0 --  GROUP BY 1 --), -- --Senders AS ( --  SELECT --    from_address AS addy, --    COALESCE(SUM(amount_precise), 0) AS sent_amount --  FROM {{transfers_table}} --  WHERE 1=1 --    AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --    AND contract_address = '{{contract_address}}' --    AND amount_usd > 0 --  GROUP BY 1 --), -- --Holders AS ( --  SELECT --    addy, --    received_amount - sent_amount AS balance, --    ROW_NUMBER() OVER (ORDER BY balance DESC) AS rank --  FROM Receivers --  LEFT JOIN Senders USING(addy) --  WHERE 1=1 --    AND addy NOT IN (SELECT address FROM {{labels_table}}) --    AND balance > 1 --  ORDER BY 2 DESC --) -- --SELECT --  balance, --  rank --FROM Holders --WHERE rank = 1000 SELECT * from base.core.ez_token_transfers WHERE contract_address = '0xcDE90558fc317C69580DeeAF3eFC509428Df9080' and block_timestamp >= '2024-04-07'
bf8b61d1-8fd9-4450-99fa-c768cb423dc9,gini-coeff,-- arbitrum.core.ez_token_transfers -- avalanche.core.ez_token_transfers -- base.core.ez_token_transfers -- bsc.core.ez_token_transfers -- ethereum.core.ez_token_transfers -- gnosis.core.ez_token_transfers -- near.core.fact_transfers -- optimism.core.ez_token_transfers -- polygon.core.ez_token_transfers -- solana.core.fact_transfers -- arbitrum.core.dim_labels -- avalanche.core.dim_labels -- base.core.dim_labels -- bsc.core.dim_labels -- ethereum.core.dim_labels -- gnosis.core.dim_labels -- near.core.dim_address_labels -- optimism.core.dim_labels -- polygon.core.dim_labels -- solana.core.dim_labels -- 0xf6e932ca12afa26665dc4dde7e27be02a7c02e50 -- %% GINI COEFFICIENT %% --EVM --WITH Receivers AS ( --  SELECT --    to_address AS addy, --    SUM(amount) AS received_amount --  FROM {{transfers_table}} --  WHERE 1=1 --    AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --    AND contract_address = '{{contract_address}}' --    AND amount_usd > 0 --  GROUP BY 1 --), -- --Senders AS ( --  SELECT --    from_address AS addy, --    COALESCE(SUM(amount), 0) AS sent_amount --  FROM {{transfers_table}} --  WHERE 1=1 --    AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --    AND contract_address = '{{contract_address}}' --    AND amount_usd > 0 --  GROUP BY 1 --), -- --Holders AS ( --SELECT --  addy, --  received_amount - sent_amount AS balance --FROM Receivers --LEFT JOIN Senders USING(addy) --WHERE 1=1 --  AND addy NOT IN (SELECT address FROM {{labels_table}}) --  AND balance > 1 --ORDER BY 2 DESC --LIMIT 100 --), -- --Stats AS ( --  SELECT --    (2 * AVG(balance) * pow(100, 2)) AS denom --  FROM Holders --), -- --X_i AS ( --  SELECT --    balance AS x_i --  FROM Holders --), -- --X_j AS ( --  SELECT --    balance AS x_j --  FROM Holders --), -- --Gini AS ( --SELECT --  SUM(ABS(x_i - x_j)) AS rect_sum --FROM X_i --CROSS JOIN X_j --) -- --SELECT --  100 * ROUND(rect_sum / denom, 2) AS gini_coeff --FROM Gini, Stats --SOLANA WITH Receivers AS (   SELECT     tx_to AS addy,     SUM(amount) AS received_amount   FROM {{transfers_table}}   WHERE 1=1     AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'     AND mint = '{{contract_address}}'     AND amount > 100   GROUP BY 1 ), Senders AS (   SELECT     tx_from AS addy,     SUM(amount) AS sent_amount   FROM {{transfers_table}}   WHERE 1=1     AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'     AND mint = '{{contract_address}}'     AND amount > 100   GROUP BY 1 ), Holders AS ( SELECT   addy,   received_amount - sent_amount AS balance FROM Receivers LEFT JOIN Senders USING(addy) WHERE 1=1   AND balance > 1 ORDER BY 2 DESC LIMIT 100 ), Stats AS (   SELECT     (2 * AVG(balance) * pow(100, 2)) AS denom   FROM Holders ), X_i AS (   SELECT     balance AS x_i   FROM Holders ), X_j AS (   SELECT     balance AS x_j   FROM Holders ), Gini AS ( SELECT   SUM(ABS(x_i - x_j)) AS rect_sum FROM X_i CROSS JOIN X_j ) SELECT   100 * ROUND(rect_sum / denom, 2) AS gini_coeff FROM Gini, Stats
50757ce1-ca71-4321-b3d7-d42e341bc2c7,biggest-buy-sell,-- arbitrum.defi.ez_dex_swaps -- avalanche.defi.ez_dex_swaps -- base.defi.ez_dex_swaps -- bsc.defi.ez_dex_swaps -- ethereum.defi.ez_dex_swaps -- gnosis.defi.ez_dex_swaps -- near.defi.ez_dex_swaps -- optimism.defi.ez_dex_swaps -- polygon.defi.ez_dex_swaps -- solana.defi.fact_swaps -- 0xf6e932ca12afa26665dc4dde7e27be02a7c02e50 -- %% 6-month biggest BUY and SELL %%  --EVM --SELECT --  ROUND(MAX(CASE WHEN token_in = '{{contract_address}}' THEN amount_in_usd END)) AS biggest_sell, --  ROUND(MAX(CASE WHEN token_out = '{{contract_address}}' THEN amount_out_usd END)) AS biggest_buy --FROM {{swap_table}} --WHERE 1=1 --  AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --  AND (token_in = '{{contract_address}}' --    OR token_out = '{{contract_address}}' --  ) -- SOLANA WITH Sell AS (   SELECT     ROUND(MAX(swap_from_amount * close)) AS biggest_sell,     MAX_BY(DATE_TRUNC('day', swp.block_timestamp), swap_from_amount * close) AS sell_date   FROM solana.defi.fact_swaps swp   INNER JOIN solana.price.ez_token_prices_hourly prc     ON DATE_TRUNC('hour', swp.block_timestamp) = prc.recorded_hour     AND swp.swap_from_mint = prc.token_address   WHERE 1=1     AND swp.block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'     AND swap_from_mint = '{{contract_address}}' ), Buy AS (   SELECT     ROUND(MAX(swap_to_amount * close)) AS biggest_buy,     MAX_BY(DATE_TRUNC('day', swp.block_timestamp), swap_from_amount * close) AS buy_date   FROM solana.defi.fact_swaps swp   INNER JOIN solana.price.ez_token_prices_hourly prc     ON DATE_TRUNC('hour', swp.block_timestamp) = prc.recorded_hour     AND swp.swap_to_mint = prc.token_address   WHERE 1=1     AND swp.block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'     AND swap_to_mint = '{{contract_address}}' ) SELECT   biggest_sell,   sell_date,   biggest_buy,   buy_date   FROM Sell, Buy
185909b7-6a78-464d-aad1-1b93a630d4a6,NFTburn-top50,WITH Txns AS ( SELECT   DISTINCT tx_id AS tx FROM solana.core.fact_events WHERE program_id = 'bondwbhv3sqgBgtzDZmyeohLrga26AcNiBvJ6jQzwgd'   AND block_timestamp >= '2024-01-25' ), LBoard AS (   SELECT     signers[0] AS signer,     COUNT(CASE WHEN program_id = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' THEN 1 END) AS "nfts burned",     ROW_NUMBER() OVER (ORDER BY "nfts burned" DESC) AS rank   FROM solana.core.fact_events   WHERE 1=1     AND tx_id IN (SELECT tx FROM Txns)     AND block_timestamp >= '2024-01-25'     AND succeeded   GROUP BY 1 ) SELECT   signer,   "nfts burned",   rank FROM LBoard WHERE rank <= 50 ORDER BY 3 ASC
58c381a2-2ea1-4623-885e-1978afadcdcb,monad,-- price -- transfers: big number -- dex swaps: bar chart -- dex volume: bar chart -- liquidity -- BASE WETH: 0x4200000000000000000000000000000000000006 -- ARB ARB: 0x912CE59144191C1204E64559FE8253a0e49E6548 -- AVA WAVAX: 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7 -- BSC WBNB: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c -- ETH WETH: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 -- GNOS GNOSIS: 0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb -- OP OP: 0x4200000000000000000000000000000000000042 -- POLY MATIC: 0x0000000000000000000000000000000000001010 -- SOL WSOL: So11111111111111111111111111111111111111112 -- %% 6-month DAILY SWAP VOLUME & VOLUME MA %% --SELECT --  DATE_TRUNC('day', block_timestamp) AS date, --  SUM(amount_in_usd) AS daily_vol, --  SUM(swap_volume_USD) OVER (ORDER BY date) AS alltime_swap_volume_USD, --  AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS "7D MA", --  AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS "14D MA", --  AVG(daily_vol) OVER (ORDER BY date ROWS BETWEEN 30 PRECEDING AND CURRENT ROW) AS "1M MA" --FROM base.defi.ez_dex_swaps --WHERE 1=1 --  AND block_timestamp >= ADD_MONTHS(CURRENT_DATE(), -6) --  AND (token_in = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --    OR token_out = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --  ) --GROUP BY 1 --ORDER BY 1 DESC -- %% 6-month biggest BUY and SELL %%  --SELECT --  MAX(CASE WHEN token_in = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' THEN amount_in_usd END) AS biggest_buy, --  MAX(CASE WHEN token_out = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' THEN amount_out_usd END) AS biggest_sell --FROM base.defi.ez_dex_swaps --WHERE 1=1 --  AND block_timestamp >= ADD_MONTHS(CURRENT_DATE(), -6) --  AND (token_in = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --    OR token_out = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --  ) -- %% 6-month UNIQUE SWAPPERS %% --SELECT --  COUNT(DISTINCT origin_from_address) --FROM base.defi.ez_dex_swaps --WHERE 1=1 --  AND block_timestamp >= ADD_MONTHS(CURRENT_DATE(), -6) --  AND (token_in = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --    OR token_out = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --  ) -- %% 1-week TOP ROTATIONS %% --WITH Rotations AS ( --SELECT --  symbol_out, --  COALESCE(SUM(amount_out_usd), 0) AS rotations, --  ROW_NUMBER() OVER (ORDER BY rotations DESC) AS rank --FROM base.defi.ez_dex_swaps --WHERE 1=1 --  AND block_timestamp >= DATEADD(WEEK, -1, CURRENT_DATE()) --  AND token_in = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --GROUP BY 1 --) --SELECT * --FROM Rotations --WHERE rank <= 5 --ORDER BY rank -- %% GROWTH FROM LAUNCH (%) & ATH %% --SELECT --  ROUND(100 * MAX_BY(price, hour) / MIN_BY(price, hour)) AS growth, --  MAX(price) AS ATH, --  ROUND(100 * MAX(price) / MIN_BY(price, hour)) AS max_growth --FROM base.price.ez_hourly_token_prices --WHERE 1=1 --  AND token_address = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --  AND hour >= '2023-09-01' -- %% COIN VS NATIVE CURRENCY GROWTH (%) %% --WITH Native AS ( --  SELECT --    DATE_TRUNC('day', hour) AS date, --    MAX_BY(price, hour) AS native_close --  FROM base.price.ez_hourly_token_prices --  WHERE 1=1 --    AND hour >= ADD_MONTHS(CURRENT_DATE(), -3) --    AND token_address = '0x4200000000000000000000000000000000000006' --  GROUP BY 1 --), -- --Coin AS ( --  SELECT --    DATE_TRUNC('day', hour) AS date, --    MAX_BY(price, hour) AS coin_close --  FROM base.price.ez_hourly_token_prices --  WHERE 1=1 --    AND hour >= ADD_MONTHS(CURRENT_DATE(), -3) --    AND token_address = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --  GROUP BY 1 --), -- --GenesisNative AS ( --  SELECT --    MIN_BY(native_close, date) AS gen_native --  FROM Native --), -- --GenesisCoin AS ( --  SELECT --    MIN_BY(coin_close, date) AS gen_coin --  FROM Coin --), -- --NativeGrowth AS ( --  SELECT --    date, --    native_close, --    100 * (native_close - gen_native) / gen_native AS native_growth --  FROM Native, GenesisNative --), -- --CoinGrowth AS ( --  SELECT --    date, --    coin_close, --    100 * (coin_close - gen_coin) / gen_coin AS coin_growth --  FROM Coin, GenesisCoin --) -- --SELECT *, --  CASE WHEN native_growth <> 0 THEN ROUND(coin_growth / native_growth, 1) ELSE 1 END AS perf_ratio --FROM NativeGrowth --JOIN CoinGrowth USING(date) --ORDER BY 1 DESC -- %% GINI COEFFICIENT %% --WITH Receivers AS ( --  SELECT --    to_address AS addy, --    SUM(amount) AS received_amount --  FROM base.core.ez_token_transfers --  WHERE 1=1 --    AND block_timestamp >= ADD_MONTHS(CURRENT_DATE(), -6) --    AND contract_address = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --    AND amount_usd > 0 --    --AND origin_from_address = '0xC5E338938916E96C55Ad7a17C36f4ed625E21e2e' --  GROUP BY 1 --), -- --Senders AS ( --  SELECT --    from_address AS addy, --    COALESCE(SUM(amount), 0) AS sent_amount --  FROM base.core.ez_token_transfers --  WHERE 1=1 --    AND block_timestamp >= ADD_MONTHS(CURRENT_DATE(), -6) --    AND contract_address = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --    AND amount_usd > 0 --    --AND origin_from_address = '0xC5E338938916E96C55Ad7a17C36f4ed625E21e2e' --  GROUP BY 1 --), -- --Holders AS ( --SELECT --  addy, --  received_amount - sent_amount AS balance --FROM Receivers --LEFT JOIN Senders USING(addy) --WHERE 1=1 --  AND addy NOT IN (SELECT address FROM base.core.dim_labels) --  AND balance > 1 --ORDER BY 2 DESC --LIMIT 100 --), -- --Stats AS ( --  SELECT --    (2 * AVG(balance) * pow(100, 2)) AS denom --  FROM Holders --), -- --X_i AS ( --  SELECT --    balance AS x_i --  FROM Holders --), -- --X_j AS ( --  SELECT --    balance AS x_j --  FROM Holders --), -- --Gini AS ( --SELECT --  SUM(ABS(x_i - x_j)) AS rect_sum --FROM X_i --CROSS JOIN X_j --) -- --SELECT --  100 * ROUND(rect_sum / denom, 2) AS gini_coeff --FROM Gini, Stats -- %% CEX IN/OUT FLOWS %% --WITH Cex AS ( --  SELECT address --  FROM base.core.dim_labels --  WHERE label_type = 'cex' --), -- --Inflows AS ( --  SELECT --    DATE_TRUNC('day', block_timestamp) AS date, --    COALESCE(SUM(amount_usd), 0) AS cex_inflows --  FROM base.core.ez_token_transfers --  WHERE 1=1 --    AND block_timestamp >= ADD_MONTHS(CURRENT_DATE(), -6) --    AND contract_address = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --    AND to_address IN (SELECT address FROM Cex) --  GROUP BY 1 --), -- --Outflows AS ( --  SELECT --    DATE_TRUNC('day', block_timestamp) AS date, --    COALESCE(SUM(amount_usd), 0) AS cex_outflows --  FROM base.core.ez_token_transfers --  WHERE 1=1 --    AND block_timestamp >= ADD_MONTHS(CURRENT_DATE(), -6) --    AND contract_address = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --    AND from_address IN (SELECT address FROM Cex) --  GROUP BY 1 --) -- -- --SELECT * --FROM Inflows --JOIN Outflows --  USING(date) --WITH pools AS ( --SELECT pool_address --FROM base.defi.dim_dex_liquidity_pools --WHERE 1=1 --  AND (tokens:token0::STRING = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --    OR tokens:token1::STRING = '0xf6e932ca12afa26665dc4dde7e27be02a7c02e50' --  ) --) -- --SELECT --  tx_hash, --  from_address, --  to_address, --  amount_usd --FROM base.core.ez_token_transfers --WHERE 1=1 --  AND (from_address IN (SELECT pool_address FROM pools) --    OR to_address IN (SELECT pool_address FROM pools)) --  AND block_timestamp >= CURRENT_DATE()
82c065b3-5ad3-4f03-a982-007683797013,CEX-flows,-- arbitrum.core.ez_token_transfers -- avalanche.core.ez_token_transfers -- base.core.ez_token_transfers -- bsc.core.ez_token_transfers -- ethereum.core.ez_token_transfers -- gnosis.core.ez_token_transfers -- near.core.fact_transfers -- optimism.core.ez_token_transfers -- polygon.core.ez_token_transfers -- solana.core.fact_transfers -- arbitrum.core.dim_labels -- avalanche.core.dim_labels -- base.core.dim_labels -- bsc.core.dim_labels -- ethereum.core.dim_labels -- gnosis.core.dim_labels -- near.core.dim_address_labels -- optimism.core.dim_labels -- polygon.core.dim_labels -- solana.core.dim_labels -- 0xf6e932ca12afa26665dc4dde7e27be02a7c02e50 -- %% CEX IN/OUT FLOWS %% --EVM --WITH Cex AS ( --  SELECT address --  FROM {{labels_table}} --  WHERE label_type = 'cex' --), -- --Inflows AS ( --  SELECT --    DATE_TRUNC('day', block_timestamp) AS date, --    COALESCE(SUM(amount_usd), 0) AS cex_inflows --  FROM {{transfer_table}} --  WHERE 1=1 --    AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --    AND contract_address = '{{contract_address}}' --    AND to_address IN (SELECT address FROM Cex) --  GROUP BY 1 --), -- --Outflows AS ( --  SELECT --    DATE_TRUNC('day', block_timestamp) AS date, --    COALESCE(SUM(amount_usd), 0) AS cex_outflows --  FROM {{transfer_table}} --  WHERE 1=1 --    AND block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks' --    AND contract_address = '{{contract_address}}' --    AND from_address IN (SELECT address FROM Cex) --  GROUP BY 1 --) -- -- --SELECT --  date, --  cex_inflows - cew_outflows AS netflow --FROM Inflows --JOIN Outflows --  USING(date) --SOLANA SELECT   SUM(case when labels_to.label IS NOT NULL then amount * close else 0 end) AS inflow,   SUM(case when labels_from.label IS NOT NULL then amount * close else 0 end) AS outflow,   inflow - outflow as net FROM solana.core.fact_transfers tsf LEFT JOIN solana.core.dim_labels labels_from   ON tsf.tx_from = labels_from.address   AND labels_from.label_type = 'cex' LEFT JOIN solana.core.dim_labels labels_to   ON transfers.tx_to = labels_to.address   AND labels_to.label_type = 'cex' INNER JOIN solana.price.ez_token_prices_hourly prices   ON DATE_TRUNC('hour', tsf.block_timestamp) = prices.recorded_hour   AND tsf.mint = prices.token_address WHERE tsf.block_timestamp >= CURRENT_DATE() - INTERVAL '{{weeks}} weeks'   AND mint = '{{contract_address}}'
3253c6ba-5804-4565-8e8d-145ef4ebba3c,sybil-checker,SELECT   block_time,   block_number,   "from",   "to",   'Arbitrum' as network,   'native' as token,   CAST('ETH' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   arbitrum.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Avalanche' as network,   'native' as token,   CAST('AVAX' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   avalanche_c.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Base' as network,   'native' as token,   CAST('ETH' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   base.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Binance' as network,   'native' as token,   CAST('BNB' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   bnb.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Celo' as network,   'native' as token,   CAST('CELO' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   celo.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Ethereum' as network,   'native' as token,   CAST('ETH' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   ethereum.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Fantom' as network,   'native' as token,   CAST('FTM' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   fantom.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Gnosis' as network,   'native' as token,   CAST('xDAI' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   gnosis.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Optimism' as network,   'native' as token,   CAST('ETH' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   optimism.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   block_time,   block_number,   "from",   "to",   'Polygon' as network,   'native' as token,   CAST('MATIC' AS VARCHAR) AS contract,   value / 1e18 as value,   hash FROM   polygon.transactions WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND block_time > TIMESTAMP {{ "Start Date" }}   AND block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Arbitrum' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_arbitrum.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_arbitrum.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'arbitrum'   ) t ON t.contract_address = CAST(     erc20_arbitrum.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Avalanche' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_avalanche_c.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_avalanche_c.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'avalanche_c'   ) t ON t.contract_address = CAST(     erc20_avalanche_c.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Base' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_base.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_base.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'base'   ) t ON t.contract_address = CAST(     erc20_base.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Binance' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_bnb.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_bnb.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'bnb'   ) t ON t.contract_address = CAST (     erc20_bnb.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'CELO' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_celo.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_celo.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'celo'   ) t ON t.contract_address = CAST (     erc20_celo.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Ethereum' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_ethereum.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_ethereum.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'ethereum'   ) t ON t.contract_address = CAST (     erc20_ethereum.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Fantom' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_fantom.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_fantom.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'fantom'   ) t ON t.contract_address = CAST (     erc20_fantom.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Gnosis' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_gnosis.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_gnosis.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'gnosis'   ) t ON t.contract_address = CAST (     erc20_gnosis.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Optimism' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_optimism.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_optimism.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'optimism'   ) t ON t.contract_address = CAST (     erc20_optimism.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Polygon' AS network,   'ERC20' AS token,   CASE     WHEN t.symbol IS NOT NULL THEN t.symbol     ELSE CAST(       erc20_polygon.evt_Transfer.contract_address AS VARCHAR     )   END AS contract,   CASE     WHEN t.decimals IS NOT NULL THEN value / POWER(10, t.decimals)     ELSE value / 1e18   END AS value,   evt_tx_hash AS hash FROM   erc20_polygon.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       symbol,       decimals     FROM       tokens.erc20     WHERE       "blockchain" = 'polygon'   ) t ON t.contract_address = CAST (     erc20_polygon.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Arbitrum' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_arbitrum.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_arbitrum.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'arbitrum'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST(     erc721_arbitrum.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Avalanche' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_avalanche_c.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_avalanche_c.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'avalanche_c'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_avalanche_c.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Base' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_base.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_base.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'base'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_base.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Binance' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_bnb.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_bnb.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'bnb'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_bnb.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Celo' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_celo.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_celo.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'celo'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_celo.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Ethereum' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_ethereum.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_ethereum.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'ethereum'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_ethereum.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Fantom' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_fantom.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_fantom.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'fantom'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_fantom.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Gnosis' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_gnosis.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_gnosis.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'gnosis'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_gnosis.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Optimism' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_optimism.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_optimism.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'optimism'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_optimism.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Polygon' AS network,   'ERC721' AS token,   COALESCE(     n.name,     CAST(       erc721_polygon.evt_Transfer.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc721_polygon.evt_Transfer   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'polygon'       AND "standard" = 'erc721'   ) n ON n.contract_address = CAST (     erc721_polygon.evt_Transfer.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Arbitrum' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_arbitrum.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_arbitrum.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'arbitrum'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST(     erc1155_arbitrum.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Avalanche' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_avalanche_c.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_avalanche_c.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'avalanche_c'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_avalanche_c.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Base' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_base.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_base.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'base'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_base.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Binance' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_bnb.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_bnb.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'bnb'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_bnb.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Celo' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_celo.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_celo.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'celo'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_celo.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Ethereum' AS network,   'ER1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_ethereum.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_ethereum.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'ethereum'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_ethereum.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Fantom' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_fantom.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_fantom.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'fantom'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_fantom.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Gnosis' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_gnosis.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_gnosis.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'gnosis'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_gnosis.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Optimism' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_optimism.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_optimism.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'optimism'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_optimism.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} UNION ALL SELECT   evt_block_time AS block_time,   evt_block_number AS block_number,   "from",   "to",   'Polygon' AS network,   'ERC1155' AS token,   COALESCE(     n.name,     CAST(       erc1155_polygon.evt_TransferSingle.contract_address AS VARCHAR     )   ) AS contract,   0.0 AS value,   evt_tx_hash AS hash FROM   erc1155_polygon.evt_TransferSingle   LEFT JOIN (     SELECT       CAST(contract_address AS VARCHAR) AS contract_address,       name     FROM       tokens.nft     WHERE       "blockchain" = 'polygon'       AND "standard" = 'erc1155'   ) n ON n.contract_address = CAST (     erc1155_polygon.evt_TransferSingle.contract_address AS VARCHAR   ) WHERE   "from" IN ({{addresses}})   AND "to" IN ({{addresses}})   AND NOT "from" = "to"   AND evt_block_time > TIMESTAMP {{ "Start Date" }}   AND evt_block_time < TIMESTAMP {{ "End Date" }} ORDER by   block_time DESC
50eb0a8e-e4bf-49e2-aefd-f0bd145ef467,OLYMPICS-ldb,WITH  Collections AS (   SELECT *   FROM VALUES     ('B9H5kWxoyzsZ2eeJym9Uf9SCcsymdy7bNYDeZQbLoEAf', 'Mad Lads'),     ('8GBmMny2oHYhkK6qRzkG4YYHQKrpVfhQc99j2RHWCYpK', 'Banx'),     ('FXH2CGdTxCpj3Y7eU6pXEgfukkyC1Syqsp7V68EVFuLB', 'Art Enjoyers'),     ('69GCjTvhgjmwvczbLzUHNH8ZGfPnzdrbXviHY4WfUXuv', 'Aurory'),     ('J1NrrDoPJmVgVGz7843d1fZBhyApWzBGzZ3PEXBQGz6M', 'Ninja Protocol'),     ('8uUZUbP1p4oGrgz44NBUZwLpJBuYcLVPiWArgwtFCuLJ', 'Golden Triangle Greens'),     ('HsRruXAD1ZGUAFLYTNL1U62Hc3vkJ9W5pEWTH6eM3erR', 'Alpha Pharaohs'),     ('6hsLdCNduFdktPGmRYcdgySWN1JNnbUxBfezXcNdM4uC', 'Sharky fi'),     ('G9BkALmTjpY1NZwFbAWxZQqLayUQNfc1RKdsDMKn9m9f', 'Degen Ape Academy'),     ('4N2u2X7kmf9jJ9MEt4p5ryCsiH1SNzYBxoq5T5ocjbmn', 'Defi Degenerates'),     ('8yPXsvDY9KXLFLCrZX3AP8BL4HM817dcxij1uB435Q4L', 'Samoyedcoin'),     ('9w2iKFcUaSDhtG5Jz8v4nTy22c7SNe1eKs43YPsNtbMA', 'The Barrows'),     ('Bdi3BDjWLpLfU74cuqFjkTuvYouM1aN3cNnH3MuueGdo', 'DeFi Land'),     ('8xGdqmwBgD2RSpGzB12wWUv3SjX5Hry65m99gPiruCyL', 'Chonky'),     ('7GCM7WE9PAJ5jR2p5SxvLBnR37eATS1NZ7oB2DtaFAp2', 'Mob Studios'),     ('D9SxGDRqqe5p2Lajcb8SfgeztXEX5EWn7f6VcdV84f8F', 'Gaimin Gladiators'),     ('6CYfQ6p4pQVs7khwMxQNdU5UZ2KnF8shgToPgDUJzQnM', 'Solana Monkey Business'),     ('DcGJHrq49PC9a8GzfY4nk4cUD1pteNzbrX3QAxnDJj5U', 'Cyber Frogs'),     ('4u2SuXfJnu62DBHy8E4gnn6r9inX5WRJ6S6rg7QKRBKu', 'Boryoku Dragonz'),     ('8sXj2Y3qgiosYLhK1SKSigbAMfde6Cjv2QceW8wsX2wR', 'Lifinity Flares'),     ('DaXZ4QNsnAqE6gwnmNgQk6hNaWhNKrmHqC2AmZxcE1jS', 'PACmates (Primates)'),     ('9CXM7HHhL7FkysD7ro67huP7LJz5Qj98hqWwZijY419o', 'Duelbots'),     ('ArJKfLhierc238TMU4aRJoRQhjizAwjxv9x6veKMihKC', 'PRNT'),     ('J5BJd2e3dtxBvfecxAEBtYpRca3Un4NjL3uvaYeF9FWw', 'Stoned Ape Crew'),     ('6PAEjY4QbshSLdsLResifogzsKcv6rn9jNwZa5ehVdii', 'Assetdash'),     ('8bSQkhxezDyrsgnBA9Wy6RhBRWNgJ9t9MmUs1QKE6uRP', 'Droid Capital'),     ('58bXPfnJSUAYteXCakaD9LJ8rPQecLmYgTKGFqwtLg5h', 'SagaDAO'),     ('H9d1iyxqBdTvgN3KyGtuadqLJiCj639tzDczjL1JiuFY', 'Bonke DAO'),     ('GG3c5JF8Dj9mQ1t31RCw5mRxSCWeNHr775VJf5fNgH5K', 'DeanslistDAO'),     ('652hz9Gys78zauwduCJiY6UhLZonskywrQEaxjATomWp', 'Ovols'),     ('3CeBuhkRjnbcSsTGyt4ff3P6XuV7dTTh7mqk7W7wcrHE', 'BONKz'),     ('38GvAgUwJncPJLCPdYnyXsDGDLPjwjcxNPiz4Mm14soW', 'CETS'),     ('GHcm3thZF31enSgz6ZN37t16yPd6uxv7gHnVychHaCcC', 'Galactic Gecko Space Garage'),     ('6sMBgycFAXT16Az6TSiasRnuEhf8ugHvfQtvVc7yXQQS', 'Clayno Capital (Claynosaurz)'),     ('8megwVN5VFrta2VPStxa2YJa5VUouSMM51ry4qhU3h7r', 'Bohemia Art Fair'),     ('6WP7rUTJotDBsgDLRANDMkNGej8fZwGe6Q2Z9ETGexVs', 'Degenerate Trading Bears'),     ('Uj2aDxv3t55rY3B19EJyEgMH2iBov1RLxS8zDvD6siN', 'Caveworld'),     ('ChHseAH1WHaSXFeWBfGy4zbaZvdEDzi1fP4gJJZ8foE6', 'Gyris'),     ('4PTTHwb1rVTJSjkDUVhvHpFFCgyCnNHfGFr54XMWvkzd', 'Degenerate Trash Pandas'),     ('DdW12z6zpwahC8w8bcWEkyFGZdnGevtorbFvdWSVzGDJ', 'WenTards'),     ('By2o65RKBGfmBemdmNhLGdr6hmX7nngjHxae2nRN8QnJ', 'GIZMOS'),     ('9vVGgMBkjSnzaUrdAPjeVAgoZ32C51oJ7TxCD2ZTa7Vy', 'Degen Fat Cats'),     ('BkjW7vso2BdsQefHTbSTRZegmSozAGHjzUxr2PyRs7QU', 'D3fenders'),     ('DvGaXRVzeSRrcew3eyHcn7FoRymh43xS3cNayckZejoF', 'Solar Moon'),     ('3z1HgaayFBQKfr4UKTrR5LgkRTmdzsmcg3iT5Hc9FeRP', 'SolPunks'),     ('AXgTHW6fus8R2jEbFJSgx5RYKzwhaUDGA7FVET1FBUNo', 'Antisocial GG'),     ('EGyN6wj8vD4NU5YrNBojB7VASvMxJsqL6P1viJifwAs7', 'Dazed Ducks'),     ('2iYGN1LJZgtBZ5akS6aoRVvtLe4kYBm6QhtWPLTNxNxo', 'KikiVerse'),     ('HLaVdYKo5Cni8hJYXbEMnR7zURByHcWxXYniBoLaq4Y6', 'Swamp Syndicate'),     ('qrBLzmGQmAXozqBi7qRo3n4L6ip9mev8qeBPFxwdZQe', 'The Sol Army'),     ('EpaVWxwRptM13KH3Cg2e98fv6UfTT5ytZoPgLosNncYS', 'ANYBODIES'),     ('96e6JYn7hhgm4oWsBLhFyPZKXYoyygHTjVK4LnPpPPFw', 'The Heist'),     ('7KuFg1QuKUUB8inHZdo5N4JuNk5icgQqmGMH2ctkoHWD', 'Guac'),     ('3GjayxpRKHqRJzQDWtjkX4cvqAcfBiNZkPy6eXiQq9ZE', 'Bored Ape Solana Club'),     ('GKiJpwLj7Lerc51wDxZsm9pmuDs9p8Ds4TCrqPPANqwq', 'Portals'),     ('C74aDt9egZDCMNhxrUHKxGrFP9UsQyevAyHwcRFDpXXx', 'Solana selfie a day with Jakey'),     ('7DCsyd1xgKdYCfq3PzDXqECLwLhgWFGidVzkKyFZqKMg', 'BabyApes'),     ('5quNp6B7U3M9VB93bYZEsZVxJAigHhCtXZz41jrG4F8R', 'Dragon Sanctuary'),     ('8L1vfRRMS4XTCfSr6vp1jpSknsL9irMi9o8s4xXyNxku', 'GMers'),     ('9CnL5UbooFqJpELTQiBDjtdxA1zonrmHWDL2Uf4B8Swb', 'The Fracture'),     ('78MTzZ7JDGo2RAyNnAwNTVQ8urFiE7xmu4o5uojrZAF5', 'DEGEN NEWS'),     ('BAUoAUfR4Y5qCspG1LueyhPV439X1UXp2jNCg5652y21', 'Grape Protocol'),     ('FyAd16zTb17uo4jnQNTxXYFeQkrtFtE4pvdvHUYr4DxR', 'Photo Finish'),     ('HPMrw9rBU3zD38agBMvV1zfrN4GnaRCqsCcSfFzNMoMF', 'BOOGLE'),     ('6qsW8Y9S3feyDrPyfYJQqDaqrfjTEKaGdhHcpPkDyVog', 'Bodoggos'),     ('GkT5y6bui3qP1GCLgXmfGeTyZDWUaEbkkKjobFD8tjBV', 'ASTRALS'),     ('CocywHJiT6NbLvSEr2u3BWsyuefbBjx2J4HxJXELwXQP', 'Wabalaba Land'),     ('CtkSRip1D6V7iYmuc2YGUZU2XvA63ZmpwFeP8aQ74NND', 'Yosu'),     ('3dCV39oEe9VxQe8xCi6mnGFCrQPD5nzWATh6zojEXzDb', 'Solluminati'),     ('7962uXdwhN99JYcJ83L3vTkY7o8gMvhj38z8oM7Z4a6y', 'Popo'),     ('7ccAZzvRdUUQLnpgZTHXVW3rQYfXYeXptUHw2675ZFPF', 'Ghostkid'),     ('FSm5Ck81NhiiappdWpAseFU5zvky5BdbPC6kAYPcD9uF', 'BitBrawl'),     ('DTgC8qVoWbEhdz7vzFY7Lr2MBK6mNpY8AzAueT2nYj1S', 'Critters Cult'),     ('EwxATn9TixEFu4cR5nqH4vcRCKGd1Zm2JnpS4yD8x6fi', 'JellyCo'),     ('7f8SVNEc9A4nr2uEQBsq2m2M8HCAhsezWqWUtLVXNSyZ', 'Namaste'),     ('HjrXtLhTyMTCPuha5TVh5sKEgwXiaw4JryC8mMB2X9VA', 'Dead King Society Nobles'),     ('9WD7B7pUawWB25q2sjDsFrKEctuPUjL6WnaFEbkKCsoi', 'The Whales'),     ('Ghz8eRBsSDwHit3A7QmQ2EcsmF1Btt4bkNV7YZR4Jz6K', 'Famous Fox Federation'),     ('Db19PdSATfV7eFLrTsyEmXuMSzCTSVQeJ1AAyXLFHivA', 'Lumio'),     ('3SKfv8xin9RakDWsvRmNo248HL94ZgGutgLYBTWC7XEe', 'Squidz'),     ('53JkhE8MDYHCXaKGFAvyauew4UY2nZGdFvh3xjmmtRH3', 'Zero Monke Biz'),     ('7TFNMySkdYGC2arMokLLrA93GpTSeQajy5Ex57XKkBDh', 'Solana Monke Rejects'),     ('Br5vjEvKBzdMKWBkNjWtEMojAwkyjSMYyKemVdgB5ERm', 'Froots'),     ('HXSkwPgs3otiDmovq6SMkD4hU6mCvcnPRr94a9V69GsM', 'AlphinesDAO'),     ('ES88NB4yxs5QxMDjUzr6FUMyAjM8UGDLyxBEAFxRdjjy', 'Just Ape'),     ('AfUCLAckP3gsngMYfdQeuhysfRdwqtSHhELXXQrK98cv', 'raccs'),     ('7dGnM64V8YSQt5AvwhmxxJcuWV4doTVHHn9U5y2dmEVf', 'CHADS'),     ('EUVpvBxdJBgLqtocYB6MzxP5sJq14UYSQXRjB42Q9anF', 'Brohalla'),     ('DDdopud5xR12gAeErHn1BmRYtYe9tB7ijMEAVEGMaq9p', 'Okay Bears'),     ('vAMmfvuqBSPZkyEKSDMcuL2vKJzhf7p5zJ3Cb4p41SC', 'Goons'),     ('H8mHEYBFALbbXCAotjQCpgfT9sWLG9mCnbnvea2JdPBv', 'Doge Capital'),     ('G9Bdocy6EhALQWgEqtTAVba6Mw9nMfAMNSceCwR6nvce', 'Quekz'),     ('Ji3KW8j29pUGgCK3EUtvPJEudkJEndVnJne78wCofq7', 'Dandies'),     ('EG2eLLA5jhTUACpHqx14m4wR6c8Mqn656VNZD8fffYYB', 'The Bastards'),     ('GzE4hPp4bHbFDohYEtpHpGTgxmY99Td3erjfrGpy1JK7', 'Bullyz Crew'),     ('9ZZmjPLXCZQLHGcZELYddigiTYXMrx7nDP8q1addcX9p', 'Crypto Machine'),     ('H33VyVCPm3uvkUf9eJqWqUn7avZgR5wkXv37sjBLj9wG', 'meegos'),     ('58Bug6jaTpSa4Ts95KUYFR82kxsimoAC5B7sW8WN3EZP', 'Grim Syndicate'),     ('FqjAwxPg9hJYsoKxNe8AWA3vnAgdX4PQsveGRcxLghVC', 'Smyths'),     ('G4dDT1t6DZ5HmtgVQuNEYjCAoJQxWVepnFD8jiAuaks6', 'Debonair Degen Hawks'),     ('3yMAJHF8Vc4LqFKcfAXnKxMjQUhBqcG1XuTJukk7Qtob', 'Pesky Penguins'),     ('CYPdZiVQNjXmmoTEAKfvjbzkeN9cYK1J1VqbxmiiegoS', 'Netrunner'),     ('4xoH2Lk7X5QVe9bQwv6RAWTCphGg2K4tcAVnw22UGHfq', 'Cyber Samurai'),     ('DtM2vLH51hDKitQWHER8zpZzYWoiWkzY8AYfn9qwS1Zr', 'Meerkat Millionaires Country Club'),     ('BfCZY1Y1aYZt6nCMsVSTLg4swjc8MWX7Zw415Sf8s6Vc', 'MoneyBoys'),     ('6XcTwABeVBaFpRdzegywojpQ7uNNDu9LrwHnFoZ2bz7a', 'Sol Slugs'),     ('5rPFGthJvHThseR5FFKUBbgTVD4yjWeHavLegpBkbYve', 'Oogy'),     ('6LhmQ9H9p4HoKZpSLiQKsbgKnPRbLQiqppHqznErSs64', 'Bubblegoose Ballers'),     ('5GL4QVUFfPZ55n2JUXDi3qgdxjUhP5sCd8us5xqkvkLi', 'Fidelion'),     ('AowinFXFBTRYiq6tcnNPJ5fF4rwePEndtB7HBvpzXPbE', 'Trippin Ape Tribe'),     ('HuTvTRTZwxangeJ1KEUQncUz8NBkVjw3cp13CovDwnc8', 'Looties'),     ('EF1Z5ymY1CD7C8hCe4Su1t2rSungnqiJoXDVJoCqtvZJ', 'Shadowy Super Coder DAO'),     ('9QgAgnfdhZGocps9FHyg92G9Ys7wCs5jFPhuoCsR5kq7', 'Crashfaces'),     ('7xaBvGKStnMpbZqh8oajxsyN8EHPvHU6WBdF9rvumRhP', 'ThugMonkez'),     ('FTayyDiiTgHYs5HtekiVccKhq2oEBuUauWryx2rbk85L', 'Wolf Capital'),     ('9mMDzgV15D1mMhD1qNXqaJWAAeFMgq1zSbQeK6zbRmod', 'SOL Decoder'),     ('5hfYuu8mPbNbzSnd2DQ1Zd2aFm8TbdAS3u9kJyDKrqFe', 'Kups by Raposa'),     ('NgYDevdV4ayoudnW3AL8ZYSWFpaSo8g5cBUkqRCFDo7', 'Solcasino'),     ('CHaeWWMD4shbuMMhjmvBhXeuvQc5wqYTJVZGaYxGJEGk', 'Turtles'),     ('GvBEHdHgVvw7HqgyHXoE62vcPsxYAHGpvx714ive2VE8', 'CHAD'),     ('FvFtf9YfMMzcHfZY2PkCDNMd9M5ztGcDPem7kUTz5Ftr', 'Giraffe Tower'),     ('FZt2TcZBofkWyHMStuDqrwB5KsDbeQ5zx89xH5F3YGcy', 'BVDCAT'),     ('E6sc8T6Bk47bzYY4v3xGvoetGskwrK1KLJMHnWKraEzE', 'Nyan Heroes'),     ('2SYempgmZfHG5yY4UGzRh8e2fxdiNN2HtUrV4LgDforr', 'Foxbyte'),     ('HBHoHRLr7szxSQhzULV9Mh75n8MJQEGtQtfTK39SU7wy', 'Xin Dragons'),     ('9B6v7srgrBrKp5z8m8sd4bieZdkTu8kZkjJW83KbKBNT', 'Monkey Baby Business'),     ('EUtmAwCdFXdyYusJxvm1fiuQbkcUAfXfRBZ5DuGtDYVr', 'Vandals'),     ('AXjCwgAGLTU1VsALYoSoeaNjaL1D3dnRupq7KpbessXc', 'Liberty Square'),     ('3ZheYLUzRffqxENrkoEkrpBnYhHPqVhfFnAojhCyzxPf', 'Trippy Bunny Tribe'),     ('6aanmM6tsDiztX3VA3sXCCD5xgs1r2HA42AsLmxcpz3J', 'VTOPIA'),     ('5KDRm6oJvXcw4oDcv4rNNB23RkL6DxjdwAwosDBqpamk', 'UndergroundDAO')   AS t(pda, name) ), Txids AS (   SELECT     tx_id   FROM solana.core.fact_events   WHERE program_id = 'bondwbhv3sqgBgtzDZmyeohLrga26AcNiBvJ6jQzwgd'     AND block_timestamp >= '2024-01-25' AND block_timestamp <= '2024-02-22' ), Burns AS (   SELECT     tx_id,     COUNT(burn_amount) AS nfts   FROM Txids   LEFT JOIN solana.nft.fact_nft_burn_actions USING(tx_id)   GROUP BY 1 ), Txns AS (   SELECT     tx_id,     log_messages   FROM solana.core.fact_transactions   WHERE 1=1     AND tx_id IN (SELECT tx_id FROM Txids)     AND block_timestamp >= '2024-01-25' AND block_timestamp <= '2024-02-22' ), Pdas AS (   SELECT     tx_id,     SUBSTRING(log.value, POSITION('-vote:' IN log.value) + 6, 44) AS pda   FROM Txns,     LATERAL FLATTEN(input => log_messages) log   WHERE log.value LIKE 'Program log: votelog%' ), Votes AS (   SELECT     tx_id,     name AS vote   FROM Pdas   JOIN Collections USING(pda) ), Sol AS (   SELECT     tx_id,     MIN_BY(amount, index) AS sol   FROM solana.core.fact_transfers   WHERE 1=1     AND tx_id IN (SELECT tx_id FROM Txids)     AND block_timestamp >= '2024-01-25' AND block_timestamp <= '2024-02-22'   GROUP BY 1 ) SELECT   vote,   SUM(nfts) AS "burned NFTs",   COALESCE(ROUND(SUM(CASE WHEN nfts = 0 THEN Sol END), 2), 0) AS "bonded SOL" FROM Burns JOIN Votes USING(tx_id) JOIN Sol USING(tx_id) GROUP BY 1 ORDER BY 3 DESC, 2 DESC
fc624e75-18b6-478d-aed0-014a3d918b45,$W 7k,WITH DropClaims AS (   SELECT     tx_to AS wallet,     amount AS airdrop   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_events USING(tx_id)   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND succeeded     AND program_id = 'Wapq3Hpv2aSKjWrh4pM8eweh8jVJB7D1nLBw9ikjVYx'     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 7000     --AND ARRAY_CONTAINS('Program log: Instruction: Claim'::variant, log_messages) ), CEX AS (   SELECT     address   FROM solana.core.dim_labels   WHERE label_type = 'cex' ), Transfers AS (   SELECT     tx_from AS wallet,     CASE WHEN tx_to IN (SELECT address FROM CEX) THEN 'cex_transfer' ELSE 'wallet_transfer' END AS tsf_type   FROM solana.core.fact_transfers   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND tx_from IN (SELECT wallet FROM DropClaims)     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 7000 ), Swaps AS (   SELECT     swapper AS wallet,     SUM(CASE WHEN swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ' THEN -swap_from_amount ELSE swap_to_amount END) AS amount_swapped   FROM solana.defi.fact_swaps   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND (          swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'       OR swap_to_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     )     AND succeeded   GROUP BY 1 ), Behaviour AS (   SELECT     wallet,     CASE       WHEN amount_swapped IS NULL THEN 'hodl'       WHEN ROUND(airdrop + amount_swapped) <= 0 THEN 'dumped everything'       WHEN (airdrop + amount_swapped > 0) AND (airdrop + amount_swapped <= airdrop) THEN 'sold some'       WHEN amount_swapped > 0 THEN 'hodl & bought more'     END AS behaviour   FROM DropClaims   LEFT JOIN Swaps     USING(wallet)    ), Summary AS (   SELECT     CASE WHEN tsf_type IS NULL THEN behaviour ELSE tsf_type END AS behaviour   FROM Behaviour   LEFT JOIN Transfers     USING(wallet) ) SELECT   behaviour,   COUNT(behaviour) AS wallets,   SUM(wallets) OVER (ORDER BY behaviour) AS "total claimers",   ROUND(100 * "total claimers" / (971), 1) AS "% wallets that claimed" FROM Summary GROUP BY 1 ORDER BY 3 DESC
1df3caa0-d74a-475c-9ea6-3624102c91c7,WEN_swappers,SELECT   COUNT(DISTINCT swapper) AS swappers FROM solana.defi.fact_swaps WHERE 1=1   AND block_timestamp > '2024-01-26 15:01:00'   AND (        swap_from_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'     OR swap_to_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'   )   AND succeeded
f48f6cc8-a1bc-4497-9132-7db5c4fd47f5,JUP_launch,WITH DropClaims AS (   SELECT DISTINCT     block_timestamp,     signers[0] AS wallet,     fee,     succeeded,     amount     --post_token_balances[0]:uiTokenAmount:uiAmount   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_transactions USING(block_id, block_timestamp, tx_id)   --RIGHT JOIN solana.core.fact_events USING(block_id, block_timestamp, tx_id)   WHERE 1=1     AND (block_timestamp >= '2024-01-31 15:00:00' AND block_timestamp < '2024-01-31 16:00:00')     --AND program_id = 'meRjbQXFNf5En86FXT2YPz1dQzLj4Yb3xK8u1MVgqpb'     AND mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'     AND ARRAY_CONTAINS('Program log: Instruction: NewClaim'::variant, log_messages)     --AND succeeded ) SELECT   DATE_TRUNC('minute', block_timestamp) AS minute,   ROUND(AVG(fee) / POW(10, 9), 6) AS "avg fee (SOL)",   ROUND(MIN(fee) / POW(10, 9), 6) AS "min fee (SOL)",   ROUND(MAX(fee) / POW(10, 9), 6) AS "max fee (SOL)",   SUM(CASE WHEN succeeded THEN 1 END) AS claimers,   SUM(CASE WHEN NOT succeeded THEN 1 END) AS "failed transactions",   SUM(claimers) OVER (ORDER BY minute ASC) AS "first hour claimers",   ROUND(100 * "first hour claimers" / 955000,1) AS "% of eligible wallets",   ROUND(SUM(CASE WHEN succeeded THEN amount ELSE 0 END)) AS jup_claimed,   SUM(jup_claimed) OVER (ORDER BY minute ASC) as "first hour JUP claimed" FROM DropClaims GROUP BY 1 ORDER BY 1
4a79b422-be2f-4310-aba0-7942c36eebd0,JUP_swapfees,WITH JupSwaps AS (   SELECT DISTINCT     block_timestamp,     swapper,     CASE        WHEN swap_to_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN' THEN swap_to_amount       WHEN swap_from_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN' THEN swap_from_amount     END AS swap_amount,     ROUND(fee / POW(10, 9), 6) AS tx_fee   FROM solana.defi.fact_swaps swp   INNER JOIN solana.core.fact_transactions txn     USING(block_timestamp, tx_id)   WHERE 1=1     AND (block_timestamp >= '2024-01-31 15:00:00') AND (block_timestamp < '2024-01-31 16:00:00')     AND (          swap_from_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'       OR swap_to_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'     ) ) SELECT   DATE_TRUNC('minute', block_timestamp) AS minute,   COUNT(DISTINCT swapper) AS traders,   COUNT(*) AS trades,   SUM(swap_amount) AS "$JUP swap amount",   ROUND(AVG(tx_fee), 6) AS "avg fee (SOL)",   ROUND(MAX(tx_fee), 6) AS "max fee (SOL)" FROM JupSwaps GROUP BY 1 ORDER BY 1
6bc517c0-62ee-46ef-a89d-1df0d499c530,JUP_localfees,WITH Txn AS(   SELECT     block_timestamp,     fee,     CASE WHEN swapper IS NOT NULL THEN 'swap' ELSE 'solana' END AS tx     --CASE WHEN fact_swaps_id IS NULL THEN fee ELSE NULL END AS solana_fee   FROM solana.core.fact_transactions   LEFT JOIN solana.defi.fact_swaps     USING(block_timestamp, tx_id)   WHERE 1=1     AND (block_timestamp >= '2024-01-31 15:00:00') AND (block_timestamp <= '2024-01-31 15:05:00')     AND (          swap_from_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'       OR swap_to_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'       OR swap_from_mint IS NULL       OR swap_to_mint IS NULL     )     AND succeeded ) SELECT   DATE_TRUNC('second', block_timestamp) AS second,   ROUND(AVG(CASE WHEN tx='solana' THEN fee ELSE NULL END) / POW(10, 9), 6) AS "avg solana fee",   ROUND(AVG(CASE WHEN tx='swap' THEN fee ELSE NULL END) / POW(10, 9), 6) AS "avg JUP swap fee" FROM Txn GROUP BY 1 ORDER BY 1
f22077f2-d829-4263-8caa-53e0fe986a09,WEN_localfees,WITH Txn AS(   SELECT     block_timestamp,     fee,     CASE WHEN swapper IS NOT NULL THEN 'swap' ELSE 'solana' END AS tx     --CASE WHEN fact_swaps_id IS NULL THEN fee ELSE NULL END AS solana_fee   FROM solana.core.fact_transactions   LEFT JOIN solana.defi.fact_swaps     USING(block_timestamp, tx_id)   WHERE 1=1     AND (block_timestamp >= '2024-01-26 15:01:00') AND (block_timestamp <= '2024-01-26 15:06:00')     AND (          swap_from_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'       OR swap_to_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'       OR swap_from_mint IS NULL       OR swap_to_mint IS NULL     )     AND succeeded ) SELECT   DATE_TRUNC('second', block_timestamp) AS second,   ROUND(AVG(CASE WHEN tx='solana' THEN fee ELSE NULL END) / POW(10, 9), 6) AS "avg solana fee",   ROUND(AVG(CASE WHEN tx='swap' THEN fee ELSE NULL END) / POW(10, 9), 6) AS "avg $WEN swap fee" FROM Txn GROUP BY 1 ORDER BY 1
3e13c223-62b8-4a1b-9d71-de8533893de6,WEN_swapfees,WITH WenSwaps AS (   SELECT DISTINCT     block_timestamp,     swapper,     CASE WHEN swap_to_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk' THEN swap_to_amount END AS buy_amount,     ROUND(fee / POW(10, 9), 6) AS tx_fee   FROM solana.defi.fact_swaps swp   INNER JOIN solana.core.fact_transactions txn     USING(block_timestamp, tx_id)   WHERE 1=1     AND (block_timestamp >= '2024-01-26 15:01:00') AND (block_timestamp < '2024-01-26 16:00:00')     AND (          swap_from_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'       OR swap_to_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'     ) ) SELECT   DATE_TRUNC('minute', block_timestamp) AS minute,   COUNT(DISTINCT swapper) AS traders,   COUNT(*) AS trades,   SUM(buy_amount) AS "$WEN buy amount",   ROUND(AVG(tx_fee), 6) AS "avg fee (SOL)",   ROUND(MAX(tx_fee), 6) AS "max fee (SOL)" FROM WenSwaps GROUP BY 1 ORDER BY 1
2af16c49-59ca-4fb1-9cfa-4408101444d8,WEN_launch,WITH DropClaims AS (   SELECT DISTINCT     block_timestamp,     signers[0] AS wallet,     fee,     succeeded     --post_token_balances[0]:uiTokenAmount:uiAmount   FROM solana.core.fact_transactions txn   INNER JOIN solana.core.fact_events evt     USING(block_id, block_timestamp, signers)   WHERE 1=1     AND (block_timestamp >= '2024-01-26 15:01:00' AND block_timestamp < '2024-01-26 16:00:00')     AND program_id = 'meRjbQXFNf5En86FXT2YPz1dQzLj4Yb3xK8u1MVgqpb'     AND ARRAY_CONTAINS('Program log: Instruction: NewClaim'::variant, log_messages)     --AND succeeded   --ORDER BY 2, 1 ) SELECT   DATE_TRUNC('minute', block_timestamp) AS minute,   ROUND(AVG(fee) / POW(10, 9), 6) AS "avg fee (SOL)",   ROUND(MIN(fee) / POW(10, 9), 6) AS "min fee (SOL)",   ROUND(MAX(fee) / POW(10, 9), 6) AS "max fee (SOL)",   SUM(CASE WHEN succeeded THEN 1 END) AS claimers,   SUM(CASE WHEN NOT succeeded THEN 1 END) AS "failed transactions",   SUM(claimers) OVER (ORDER BY minute ASC) AS "first hour claimers",   ROUND(100 * "first hour claimers" / (7*POW(10,11)/643652),1) AS "% of eligible wallets",   "first hour claimers" * 643652 AS "first hour WEN claimed" FROM DropClaims GROUP BY 1 ORDER BY 1
2c8d5ae2-4e1d-49f5-b28c-fbd17f7ebd37,JUP_swappers,SELECT   COUNT(DISTINCT swapper) AS swappers FROM solana.defi.fact_swaps WHERE 1=1   AND block_timestamp >= '2024-01-31 15:00:00'   AND (        swap_from_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'     OR swap_to_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'   )   AND succeeded
9c7b8e2b-cbef-4ee2-bfb5-4854db85dccd,$W 16k,WITH DropClaims AS (   SELECT     tx_to AS wallet,     amount AS airdrop   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_events USING(tx_id)   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND succeeded     AND program_id = 'Wapq3Hpv2aSKjWrh4pM8eweh8jVJB7D1nLBw9ikjVYx'     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 16000     --AND ARRAY_CONTAINS('Program log: Instruction: Claim'::variant, log_messages) ), CEX AS (   SELECT     address   FROM solana.core.dim_labels   WHERE label_type = 'cex' ), Transfers AS (   SELECT     tx_from AS wallet,     CASE WHEN tx_to IN (SELECT address FROM CEX) THEN 'cex_tsf' ELSE 'wallet_tsf' END AS tsf_type   FROM solana.core.fact_transfers   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND tx_from IN (SELECT wallet FROM DropClaims)     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 16000 ), Swaps AS (   SELECT     swapper AS wallet,     SUM(CASE WHEN swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ' THEN -swap_from_amount ELSE swap_to_amount END) AS amount_swapped   FROM solana.defi.fact_swaps   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND (          swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'       OR swap_to_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     )     AND succeeded   GROUP BY 1 ), Behaviour AS (   SELECT     wallet,     CASE       WHEN amount_swapped IS NULL THEN 'hodl'       WHEN ROUND(airdrop + amount_swapped) <= 0 THEN 'dumped everything'       WHEN (airdrop + amount_swapped > 0) AND (airdrop + amount_swapped <= airdrop) THEN 'sold some'       WHEN amount_swapped > 0 THEN 'hodl & bought more'     END AS behaviour   FROM DropClaims   LEFT JOIN Swaps     USING(wallet)    ), Summary AS (   SELECT     CASE WHEN tsf_type IS NULL THEN behaviour ELSE tsf_type END AS behaviour   FROM Behaviour   LEFT JOIN Transfers     USING(wallet) ) SELECT   behaviour,   COUNT(behaviour) AS wallets,   SUM(wallets) OVER (ORDER BY behaviour) AS "total claimers",   ROUND(100 * "total claimers" / (50), 1) AS "% wallets that claimed" FROM Summary GROUP BY 1 ORDER BY 3 DESC
55f05c69-9396-4821-9c6f-3881abb74f94,$W 8k,WITH DropClaims AS (   SELECT     tx_id,     MAX_BY(tx_to, index) AS wallet,     MAX_BY(amount, index) AS airdrop   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_events USING(tx_id)   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND succeeded     AND program_id = 'Wapq3Hpv2aSKjWrh4pM8eweh8jVJB7D1nLBw9ikjVYx'     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 8000   GROUP BY 1     --AND ARRAY_CONTAINS('Program log: Instruction: Claim'::variant, log_messages) ), CEX AS (   SELECT     address   FROM solana.core.dim_labels   WHERE label_type = 'cex' ), Transfers AS (   SELECT     tx_from AS wallet,     CASE WHEN tx_to IN (SELECT address FROM CEX) THEN 'cex_transfer' ELSE 'wallet_transfer' END AS tsf_type   FROM solana.core.fact_transfers   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND tx_from IN (SELECT wallet FROM DropClaims)     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 8000 ), Swaps AS (   SELECT     swapper AS wallet,     SUM(CASE WHEN swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ' THEN -swap_from_amount ELSE swap_to_amount END) AS amount_swapped   FROM solana.defi.fact_swaps   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND (          swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'       OR swap_to_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     )     AND succeeded   GROUP BY 1 ), Behaviour AS (   SELECT     wallet,     CASE       WHEN amount_swapped IS NULL THEN 'hodl'       WHEN ROUND(airdrop + amount_swapped) <= 0 THEN 'dumped everything'       WHEN (airdrop + amount_swapped > 0) AND (airdrop + amount_swapped <= airdrop) THEN 'sold some'       WHEN amount_swapped > 0 THEN 'hodl & bought more'     END AS behaviour   FROM DropClaims   LEFT JOIN Swaps     USING(wallet)    ), Summary AS (   SELECT     CASE WHEN tsf_type IS NULL THEN behaviour ELSE tsf_type END AS behaviour   FROM Behaviour   LEFT JOIN Transfers     USING(wallet) ) SELECT   behaviour,   COUNT(behaviour) AS wallets,   SUM(wallets) OVER (ORDER BY behaviour) AS "total claimers",   ROUND(100 * "total claimers" / (460 + 1081), 1) AS "% wallets that claimed" FROM Summary GROUP BY 1 ORDER BY 3 DESC
e3878311-6f56-4f63-ae38-75149960cb29,Madlads,WITH DropClaims AS (   SELECT     tx_id,     MAX_BY(tx_to, index) AS wallet,     MAX_BY(amount, index) AS airdrop   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_events USING(tx_id)   WHERE 1=1     AND block_timestamp >= '2024-04-17'     AND succeeded     AND program_id = '7DkjPwuKxvz6Viiawtbmb4CqnMKP6eGb1WqYas1airUS'     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 3200     --AND ARRAY_CONTAINS('Program log: Instruction: Claim'::variant, log_messages)   GROUP BY 1 ), CEX AS (   SELECT     address   FROM solana.core.dim_labels   WHERE label_type = 'cex' ), Transfers AS (   SELECT     tx_from AS wallet,     CASE WHEN tx_to IN (SELECT address FROM CEX) THEN 'cex_transfer' ELSE 'wallet_transfer' END AS tsf_type   FROM solana.core.fact_transfers   WHERE 1=1     AND block_timestamp >= '2024-04-17'     AND tx_from IN (SELECT wallet FROM DropClaims)     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 3200 ), Swaps AS (   SELECT     swapper AS wallet,     SUM(CASE WHEN swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ' THEN -swap_from_amount ELSE swap_to_amount END) AS amount_swapped   FROM solana.defi.fact_swaps   WHERE 1=1     AND block_timestamp >= '2024-04-17'     AND (          swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'       OR swap_to_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     )     AND succeeded   GROUP BY 1 ), Behaviour AS (   SELECT     wallet,     CASE       WHEN amount_swapped IS NULL THEN 'hodl'       WHEN ROUND(airdrop + amount_swapped) <= 0 THEN 'dumped everything'       WHEN (airdrop + amount_swapped > 0) AND (airdrop + amount_swapped <= airdrop) THEN 'sold some'       WHEN amount_swapped > 0 THEN 'hodl & bought more'     END AS behaviour   FROM DropClaims   LEFT JOIN Swaps     USING(wallet)    ), Summary AS (   SELECT     CASE WHEN tsf_type IS NULL THEN behaviour ELSE tsf_type END AS behaviour   FROM Behaviour   LEFT JOIN Transfers     USING(wallet) ) SELECT   behaviour,   COUNT(behaviour) AS wallets,   SUM(wallets) OVER (ORDER BY behaviour) AS "total claimers",   ROUND(100 * "total claimers" / 4069, 1) AS "% wallets that claimed" FROM Summary GROUP BY 1 ORDER BY 3 DESC --SELECT --  tx_id, --  MAX_BY(tx_to, index) AS wallet, --  MAX_BY(amount, index) AS airdrop --FROM solana.core.fact_transfers --INNER JOIN solana.core.fact_events USING(tx_id) --WHERE 1=1 --  AND block_timestamp >= '2024-04-17' --  AND succeeded --  AND program_id = '7DkjPwuKxvz6Viiawtbmb4CqnMKP6eGb1WqYas1airUS' --  AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ' --  AND amount = 3200 --GROUP BY 1 --ORDER BY 1
615fe6df-0037-421c-ae7f-a952825417a4,$W 14k,WITH DropClaims AS (   SELECT     tx_to AS wallet,     amount AS airdrop   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_events USING(tx_id)   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND succeeded     AND program_id = 'Wapq3Hpv2aSKjWrh4pM8eweh8jVJB7D1nLBw9ikjVYx'     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 14000     --AND ARRAY_CONTAINS('Program log: Instruction: Claim'::variant, log_messages) ), CEX AS (   SELECT     address   FROM solana.core.dim_labels   WHERE label_type = 'cex' ), Transfers AS (   SELECT     tx_from AS wallet,     CASE WHEN tx_to IN (SELECT address FROM CEX) THEN 'cex_transfer' ELSE 'wallet_transfer' END AS tsf_type   FROM solana.core.fact_transfers   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND tx_from IN (SELECT wallet FROM DropClaims)     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 14000 ), Swaps AS (   SELECT     swapper AS wallet,     SUM(CASE WHEN swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ' THEN -swap_from_amount ELSE swap_to_amount END) AS amount_swapped   FROM solana.defi.fact_swaps   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND (          swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'       OR swap_to_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     )     AND succeeded   GROUP BY 1 ), Behaviour AS (   SELECT     wallet,     CASE       WHEN amount_swapped IS NULL THEN 'hodl'       WHEN ROUND(airdrop + amount_swapped) <= 0 THEN 'dumped everything'       WHEN (airdrop + amount_swapped > 0) AND (airdrop + amount_swapped <= airdrop) THEN 'sold some'       WHEN amount_swapped > 0 THEN 'hodl & bought more'     END AS behaviour   FROM DropClaims   LEFT JOIN Swaps     USING(wallet)    ), Summary AS (   SELECT     CASE WHEN tsf_type IS NULL THEN behaviour ELSE tsf_type END AS behaviour   FROM Behaviour   LEFT JOIN Transfers     USING(wallet) ) SELECT   behaviour,   COUNT(behaviour) AS wallets,   SUM(wallets) OVER (ORDER BY behaviour) AS "total claimers",   ROUND(100 * "total claimers" / (114), 1) AS "% wallets that claimed" FROM Summary GROUP BY 1 ORDER BY 3 DESC
a269841b-48db-4ad7-9f4e-0a8e0df8cbbf,$W 2k,WITH DropClaims AS (   SELECT     tx_to AS wallet,     amount AS airdrop   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_events USING(tx_id)   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND succeeded     AND program_id = 'Wapq3Hpv2aSKjWrh4pM8eweh8jVJB7D1nLBw9ikjVYx'     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 2000     --AND ARRAY_CONTAINS('Program log: Instruction: Claim'::variant, log_messages) ), CEX AS (   SELECT     address   FROM solana.core.dim_labels   WHERE label_type = 'cex' ), Transfers AS (   SELECT     tx_from AS wallet,     CASE WHEN tx_to IN (SELECT address FROM CEX) THEN 'cex_transfer' ELSE 'wallet_transfer' END AS tsf_type   FROM solana.core.fact_transfers   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND tx_from IN (SELECT wallet FROM DropClaims)     AND mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND amount = 2000 ), Swaps AS (   SELECT     swapper AS wallet,     SUM(CASE WHEN swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ' THEN -swap_from_amount ELSE swap_to_amount END) AS amount_swapped   FROM solana.defi.fact_swaps   WHERE 1=1     AND block_timestamp >= '2024-04-03 11:00:00'     AND (          swap_from_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'       OR swap_to_mint = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     )     AND succeeded   GROUP BY 1 ), Behaviour AS (   SELECT     wallet,     CASE       WHEN amount_swapped IS NULL THEN 'hodl'       WHEN ROUND(airdrop + amount_swapped) <= 0 THEN 'dumped everything'       WHEN (airdrop + amount_swapped > 0) AND (airdrop + amount_swapped <= airdrop) THEN 'sold some'       WHEN amount_swapped > 0 THEN 'hodl & bought more'     END AS behaviour   FROM DropClaims   LEFT JOIN Swaps     USING(wallet)    ), Summary AS (   SELECT     CASE WHEN tsf_type IS NULL THEN behaviour ELSE tsf_type END AS behaviour   FROM Behaviour   LEFT JOIN Transfers     USING(wallet) ) SELECT   behaviour,   COUNT(behaviour) AS wallets,   SUM(wallets) OVER (ORDER BY behaviour) AS "total claimers",   ROUND(100 * "total claimers" / (500 + 10000 + 7844), 1) AS "% wallets that claimed" FROM Summary GROUP BY 1 ORDER BY 3 DESC
1876831c-0410-4ee8-9dc3-02dbc349f002,top-rotations,-- 0xf6e932ca12afa26665dc4dde7e27be02a7c02e50 -- arbitrum.defi.ez_dex_swaps -- avalanche.defi.ez_dex_swaps -- base.defi.ez_dex_swaps -- bsc.defi.ez_dex_swaps -- ethereum.defi.ez_dex_swaps -- gnosis.defi.ez_dex_swaps -- near.defi.ez_dex_swaps -- optimism.defi.ez_dex_swaps -- polygon.defi.ez_dex_swaps -- solana.defi.fact_swaps -- %% 1-week TOP ROTATIONS %% --EVM --WITH Rotations AS ( --SELECT --  symbol_out, --  COALESCE(SUM(amount_out_usd), 0) AS rotations, --  ROW_NUMBER() OVER (ORDER BY rotations DESC) AS rank --FROM {{swap_table}} --WHERE 1=1 --  AND block_timestamp >= CURRENT_DATE() - INTERVAL '1 weeks' --  AND token_in = '{{contract_address}}' --GROUP BY 1 --) --SELECT * --FROM Rotations --WHERE rank <= 5 --ORDER BY rank --SOLANA WITH Rotations AS ( SELECT   symbol,   COALESCE(SUM(swap_to_amount * close), 0) AS rotations,   ROW_NUMBER() OVER (ORDER BY rotations DESC) AS rank FROM solana.defi.fact_swaps swp INNER JOIN solana.price.ez_token_prices_hourly prc   ON DATE_TRUNC('hour', swp.block_timestamp) = prc.recorded_hour   AND swp.swap_to_mint = prc.token_address WHERE 1=1   AND swp.block_timestamp >= CURRENT_DATE() - INTERVAL '1 weeks'   AND swap_from_mint = '{{contract_address}}'   AND swap_to_mint != 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'   AND swap_to_mint != 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'   AND swap_to_mint != 'So11111111111111111111111111111111111111112' GROUP BY 1 ) SELECT * FROM Rotations WHERE rank <= 5 ORDER BY rank
97a20a1e-5eb1-4ec4-bbea-daaba34c13f6,JUP_hold,WITH DropClaims AS (   SELECT     tx_id,     MAX_BY(tx_to, index) AS wallet,     amount   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_events USING(block_id, block_timestamp, tx_id)   WHERE 1=1     AND block_timestamp >= '2024-01-31 14:00:00'     AND succeeded     AND program_id = 'meRjbQXFNf5En86FXT2YPz1dQzLj4Yb3xK8u1MVgqpb'     AND mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'     --AND ARRAY_CONTAINS('Program log: Instruction: NewClaim'::variant, log_messages)   GROUP BY 1,3 ), Swaps AS (   SELECT     swapper AS wallet,     SUM(CASE WHEN swap_from_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN' THEN -swap_from_amount ELSE swap_to_amount END) AS amount_swapped   FROM solana.defi.fact_swaps   WHERE 1=1     AND block_timestamp >= '2024-01-31 15:00:00'     AND (          swap_from_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'       OR swap_to_mint = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'     )     AND succeeded   GROUP BY 1 ), Behaviour AS (   SELECT     CASE       WHEN amount_swapped IS NULL THEN 'hodl/transfer'       ELSE         CASE           WHEN airdrop + amount_swapped = 0 THEN 'dumped everything'           WHEN (airdrop + amount_swapped > 0) AND (airdrop + amount_swapped < airdrop) THEN 'sold some'           WHEN amount_swapped > 0 THEN 'hodl & bought more'         END     END AS behaviour,     claims,     airdrop   FROM (     SELECT       wallet,       COUNT(tx_id) AS claims,       SUM(amount) AS airdrop     FROM DropClaims     GROUP by 1   )   LEFT JOIN Swaps     USING(wallet)    ) SELECT   behaviour,   COUNT(behaviour) AS wallets,   SUM(airdrop) AS claimed_jup,   SUM(claims) AS claimers,   SUM(claimers) OVER (ORDER BY behaviour) AS "total claimers",   ROUND(100 * SUM(claimed_jup) OVER (ORDER BY behaviour)/ pow(10,9), 1) AS "% of JUP claimed",   ROUND(100 * "total claimers" / 955000, 1) AS "% wallets that claimed" FROM Behaviour GROUP BY 1 ORDER BY 5 DESC
12a2e9ef-2320-4561-a631-810b8428cf01,WEN_hodl,WITH DropClaims AS (   SELECT DISTINCT     block_timestamp,     signers[0] AS wallet     --post_token_balances[0]:uiTokenAmount:uiAmount   FROM solana.core.fact_transfers   INNER JOIN solana.core.fact_transactions     USING(block_id, block_timestamp)   WHERE 1=1     AND block_timestamp >= '2024-01-26 15:01:00'     --AND succeeded     AND mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'     --AND program_id = 'meRjbQXFNf5En86FXT2YPz1dQzLj4Yb3xK8u1MVgqpb'     AND ARRAY_CONTAINS('Program log: Instruction: NewClaim'::variant, log_messages)     --AND signers[0] = '8mR9JwadNcpRtZXYAH711wh6SobFN4jWyAkQW8KZw6PE'   --ORDER BY 2, 1 ), Swaps AS (   SELECT     swapper AS wallet,     SUM(CASE WHEN swap_from_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk' THEN -swap_from_amount ELSE swap_to_amount END) AS amount_swapped   FROM solana.defi.fact_swaps   WHERE 1=1     AND block_timestamp >= '2024-01-26 15:01:00'     AND (          swap_from_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'       OR swap_to_mint = 'WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk'     )     AND succeeded   GROUP BY 1 ), Behaviour AS (   SELECT     CASE       WHEN amount_swapped IS NULL THEN 'hodl/transfer'       ELSE          CASE           WHEN 643652 + amount_swapped = 0 THEN 'dumped everything'           WHEN (643652 + amount_swapped > 0) AND (643652 + amount_swapped < 643652) THEN 'sold some'           WHEN 643652 + amount_swapped > 643652 THEN 'hodl & bought more'         END     END AS behaviour   FROM DropClaims   LEFT JOIN Swaps     USING(wallet) ) SELECT   behaviour,   COUNT(behaviour) AS wallets,   SUM(wallets) OVER (ORDER BY behaviour) AS "total claimers",   ROUND(100 * "total claimers" / (7*POW(10,11)/643652),1) AS "% of eligible wallets" FROM Behaviour GROUP BY 1 ORDER BY 3 DESC --Claim tx failure --Claim tx fee --Gauging hype: % of eligible wallets who claimed in the first X hours --Total claimers so far (number and %) --Total amount claimed so far (amount and %) --How many wallets dumped their airdrop, how many are holding, how many have bought more (many different charts can be created for these metrics)
9db22a63-c833-4975-a8ee-48449ed4ccfa,W vs all,-- PYTH: HZ1JovNiVvGrGNiiYvEozEVgZ58xaU3RKwX8eACQBCt3 -- JTO: jtojtomepa8beP8AuQc6eXt5FriJwfFMwQx2v2f9mCL -- JUP: JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN -- W: 85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ WITH PythClose AS (   SELECT     ROW_NUMBER() OVER (ORDER BY recorded_hour) AS rank,      recorded_hour,     close   FROM solana.price.ez_token_prices_hourly   WHERE 1=1     AND token_address = 'HZ1JovNiVvGrGNiiYvEozEVgZ58xaU3RKwX8eACQBCt3'     AND recorded_hour BETWEEN '2023-11-20 15:00:00.000' AND DATE('2023-11-20 15:00:00.000') + INTERVAL '990 hours' ), PythMin AS (   SELECT     MIN_BY(close, recorded_hour) AS pyth_min   FROM PythClose ), Pyth AS (   SELECT     rank,     100 * close / pyth_min AS pyth_growth   FROM PythClose, PythMin ), JtoClose AS (   SELECT     ROW_NUMBER() OVER (ORDER BY recorded_hour) AS rank,      recorded_hour,     close   FROM solana.price.ez_token_prices_hourly   WHERE 1=1     AND token_address = 'jtojtomepa8beP8AuQc6eXt5FriJwfFMwQx2v2f9mCL'     AND recorded_hour BETWEEN '2023-12-07 17:00:00.000' AND DATE('2023-12-07 17:00:00.000') + INTERVAL '990 hours' ), JtoMin AS (   SELECT     MIN_BY(close, recorded_hour) AS jto_min   FROM JtoClose ), Jto AS (   SELECT     rank,     100 * close / jto_min AS jto_growth   FROM JtoClose, JtoMin ), JupClose AS (   SELECT     ROW_NUMBER() OVER (ORDER BY recorded_hour) AS rank,     recorded_hour,     close   FROM solana.price.ez_token_prices_hourly   WHERE 1=1     AND token_address = 'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'     AND recorded_hour BETWEEN '2024-02-01 01:00:00.000' AND DATE('2024-02-01 01:00:00.000') + INTERVAL '990 hours' ), JupMin AS (   SELECT     MIN_BY(close, recorded_hour) AS Jup_min   FROM JupClose ), Jup AS (   SELECT     rank,     100 * close / jup_min AS jup_growth   FROM JupClose, JupMin ), WClose AS (   SELECT     ROW_NUMBER() OVER (ORDER BY hour) AS rank,      hour,     price   FROM crosschain.price.ez_prices_hourly   WHERE 1=1     AND blockchain = 'solana'     AND token_address = '85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ'     AND hour BETWEEN '2024-04-03 12:00:00.000' AND DATE('2024-04-03 12:00:00.000') + INTERVAL '990 hours' ), WMin AS (   SELECT     MIN_BY(price, hour) AS w_min   FROM WClose ), W AS (   SELECT     rank,     hour,     100 * price / w_min AS w_growth   FROM WClose, WMin   ORDER BY 2 ), --WStats AS ( --  SELECT --    AVG(w_close) AS w_avg, --    STDDEV_SAMP(w_close) AS w_std --  FROM W --), --NormW AS ( --  SELECT --    rank, --    (w_close - w_avg) / w_std AS w_zscore --  FROM W, WStats --) PrclClose AS (   SELECT     ROW_NUMBER() OVER (ORDER BY hour) AS rank,      hour,     price   FROM crosschain.price.ez_prices_hourly   WHERE 1=1     AND blockchain = 'solana'     AND token_address = '4LLbsb5ReP3yEtYzmXewyGjcir5uXtKFURtaEUVC2AHs'     AND hour BETWEEN '2024-04-16 14:00:00.000' AND DATE('2024-04-16 14:00:00.000') + INTERVAL '990 hours' ), PrclMin AS (   SELECT     MIN_BY(price, hour) AS prcl_min   FROM PrclClose ), Prcl AS (   SELECT     rank,     hour,     100 * price / prcl_min AS prcl_growth   FROM PrclClose, PrclMin   ORDER BY 2 ), TnsrClose AS (   SELECT     ROW_NUMBER() OVER (ORDER BY hour) AS rank,      hour,     price   FROM crosschain.price.ez_prices_hourly   WHERE 1=1     AND blockchain = 'solana'     AND token_address = 'TNSRxcUxoT9xBG3de7PiJyTDYu7kskLqcpddxnEJAS6'     AND hour BETWEEN '2024-04-08 15:00:00.000' AND DATE('2024-04-08 15:00:00.000') + INTERVAL '990 hours' ), TnsrMin AS (   SELECT     MIN_BY(price, hour) AS tnsr_min   FROM TnsrClose ), Tnsr AS (   SELECT     rank,     hour,     100 * price / tnsr_min AS tnsr_growth   FROM TnsrClose, TnsrMin   ORDER BY 2 ), KmnoClose AS (   SELECT     ROW_NUMBER() OVER (ORDER BY hour) AS rank,      hour,     open   FROM solana.price.fact_prices_ohlc_hourly   WHERE 1=1     --AND blockchain = 'solana'     --AND token_address = 'KMNo3nJsBXfcpJTVhZcXLW7RmTwTt4GVFE7suUBo9sS'     AND asset_id = 'kamino'     AND hour BETWEEN '2024-04-30 11:00:00.000' AND DATE('2024-04-30 11:00:00.000') + INTERVAL '990 hours' ), KmnoMin AS (   SELECT     MIN_BY(open, hour) AS kmno_min   FROM KmnoClose ), Kmno AS (   SELECT     rank,     hour,     100 * open / kmno_min AS kmno_growth   FROM KmnoClose, KmnoMin   ORDER BY 2 ), DriftClose AS (   SELECT     ROW_NUMBER() OVER (ORDER BY hour) AS rank,      hour,     open   FROM solana.price.fact_prices_ohlc_hourly   WHERE 1=1     --AND blockchain = 'solana'     --AND token_address = 'KMNo3nJsBXfcpJTVhZcXLW7RmTwTt4GVFE7suUBo9sS'     AND asset_id = 'drift-protocol'     AND hour BETWEEN '2024-05-16 11:00:00.000' AND DATE('2024-05-16 11:00:00.000') + INTERVAL '990 hours' ), DriftMin AS (   SELECT     MIN_BY(open, hour) AS drift_min   FROM DriftClose ), Drift AS (   SELECT     rank,     hour,     100 * open / drift_min AS drift_growth   FROM DriftClose, DriftMin   ORDER BY 2 ) SELECT   rank,   pyth_growth,   jto_growth,   jup_growth,   w_growth,   prcl_growth,   tnsr_growth,   kmno_growth,   drift_growth FROM Pyth LEFT JOIN Jto USING(rank) LEFT JOIN Jup USING(rank) LEFT JOIN W USING(rank) LEFT JOIN Prcl USING(rank) LEFT JOIN Tnsr USING(rank) LEFT JOIN Kmno USING(rank) LEFT JOIN Drift USING(rank) ORDER BY 1 --SELECT --  rank, --  jto_z, --  pyth_z --FROM NormPyth --LEFT JOIN NormJto USING(rank)
b3c35e12-5d0a-4af8-951c-f3c41c0d68b9,Redao-RE,WITH  Emissions AS (   SELECT     ROUND(SUM(amount)) + 261782671 AS RE,  -- 261,782,671 $RE: other emissions     'emitted' AS status,     1 AS current_epoch,     ROUND(100 * RE / pow(10, 9), 1) AS epoch_progress   FROM solana.core.fact_transfers   WHERE 1=1     AND block_timestamp >= '2024-01-25'     AND mint = 'REdaoGk6EcBVgXW7vHs9FnzWmkr3ba6eHRBBgEtLNWo'     AND tx_from = 'CtipwGnjbhe3BBSZHLnh2XL4KEyZspr5dFVsa7ThtMr2' ) SELECT * FROM Emissions FULL OUTER JOIN (   SELECT     pow(10, 9) - RE AS RE,     'non emitted' AS status,     current_epoch,     epoch_progress   FROM Emissions ) USING(RE, status, current_epoch, epoch_progress) ORDER BY 2 -- -- --SELECT * FROM VALUES --  ((SELECT RE_emissions FROM Emissions), '1B $RE', (SELECT epoch_progress FROM Emissions)),  --  (pow(10, 9) - (SELECT RE_emissions FROM Emissions), '1B $RE', (SELECT epoch_progress FROM Emissions)) --AS t(RE_emissions, current_epoch, epoch_progress)
95d25d50-0413-45b5-a856-8b42e4538a93,REdaopass-top50,WITH  PassTxns AS (   SELECT      mint,     tx_to,     ROW_NUMBER() OVER (PARTITION BY mint ORDER BY block_timestamp DESC) AS rank   FROM solana.nft.dim_nft_metadata   INNER JOIN solana.core.fact_transfers USING(mint)   WHERE collection_id = 'RE14KiF8VLZjxUkJpFQBtjTsmWzcRPuHPqXrNZFSQnU'     AND block_timestamp >= '2023-11-01' ), Holders AS (   SELECT     tx_to AS holder,     COUNT(mint) AS nfts,     ROW_NUMBER() OVER (ORDER BY nfts DESC) AS rank   FROM PassTxns   WHERE rank = 1   GROUP BY 1 ) SELECT * FROM Holders WHERE rank <= 50 ORDER BY nfts DESC, rank ASC
2dea7a2d-8fc1-4ad0-aaaf-a4ce5e08c540,REdao-reserve,WITH Txns AS (   SELECT     tx_id   FROM solana.core.fact_events   WHERE program_id = 'bondwbhv3sqgBgtzDZmyeohLrga26AcNiBvJ6jQzwgd'     AND block_timestamp >= '2024-01-25'     AND succeeded   GROUP BY 1 ) SELECT   DATE_TRUNC('day', block_timestamp) AS day,   ROUND(SUM(CASE WHEN tx_to = 'AwBzBJJ1kYj34DJcWhSUMac5N87jGpoPUMncsPxBoDdc' THEN amount END), 1) AS dev,   ROUND(SUM(CASE WHEN tx_to = '3jZp1qmZDaVQvNcDdDTx4F4WGPLAExFv6Kymy6McboW4' THEN amount END), 1) AS t_res,   ROUND(SUM(CASE WHEN tx_to = '9bAbMPEToWLB8JSk2qvhfVzQih4jyH5JXpHXPQ6iUVc9' THEN amount END), 1) AS t_plus,   dev + t_res + t_plus AS "daily pledged SOL",   SUM(dev) OVER (ORDER BY day) AS "dev fund",   SUM(t_res) OVER (ORDER BY day) AS "treasury reserve",   SUM(t_plus) OVER (ORDER BY day) AS "treasury surplus",   "dev fund" + "treasury reserve" + "treasury surplus" AS "total pledged SOL" FROM solana.core.fact_transfers WHERE 1=1   AND block_timestamp >= '2024-01-25'   AND tx_id IN (SELECT tx_id FROM Txns)   AND (        tx_to = 'AwBzBJJ1kYj34DJcWhSUMac5N87jGpoPUMncsPxBoDdc' --dev fund     OR tx_to = '3jZp1qmZDaVQvNcDdDTx4F4WGPLAExFv6Kymy6McboW4' --treasury reserve     OR tx_to = '9bAbMPEToWLB8JSk2qvhfVzQih4jyH5JXpHXPQ6iUVc9' --treasury surplus   ) GROUP BY 1 ORDER BY 1 DESC
2de0897b-c610-402e-a38a-eca15a514ab6,REdao-highlights,WITH  Txns AS(   SELECT     tx_id   FROM solana.core.fact_events   WHERE program_id = 'bondwbhv3sqgBgtzDZmyeohLrga26AcNiBvJ6jQzwgd'     AND block_timestamp >= '2024-01-25'     AND succeeded   GROUP BY 1 ), NftBurns AS (   SELECT     tx_id,     signers[0] AS signer,     COUNT(program_id) AS nfts   FROM solana.core.fact_events   WHERE 1=1     AND tx_id IN (SELECT tx_id FROM Txns)     AND program_id = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'     AND block_timestamp >= '2024-01-25'     AND succeeded   GROUP BY 1, 2 ), Rent AS (   SELECT     tx_id,     MIN_BY(amount, index) AS rent   FROM solana.core.fact_transfers   WHERE block_timestamp >= '2024-01-25'     AND tx_id IN (SELECT tx_id FROM NftBurns)   GROUP BY 1 ) SELECT   SUM(nfts) AS "nfts burned",   ROUND(SUM(rent), 1) AS "total REnt REclaimed",   COUNT(DISTINCT signer) AS "participants" FROM NftBurns JOIN Rent USING(tx_id)
4d3a1af1-ebb8-43fa-845f-20231727b2cb,SOLbond-top50,WITH Txns AS ( SELECT   tx_id AS tx,   ARRAY_AGG(program_id) AS programs FROM solana.core.fact_events WHERE program_id = 'bondwbhv3sqgBgtzDZmyeohLrga26AcNiBvJ6jQzwgd'   AND block_timestamp >= '2024-01-25'   AND succeeded GROUP BY 1 ), Tsf AS (   SELECT     tx_id,     tx_from AS pledger,     MIN_BY(amount, index) AS bonded_sol   FROM solana.core.fact_transfers   WHERE 1=1     AND tx_id IN (SELECT tx FROM Txns WHERE NOT ARRAY_CONTAINS('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'::variant, programs))     AND mint = 'So11111111111111111111111111111111111111112'     AND block_timestamp >= '2024-01-25'   GROUP BY 1, 2 ) SELECT   pledger,   "total bonded SOL",   rank FROM ( SELECT   pledger,   ROUND(SUM(bonded_sol), 1) AS "total bonded SOL",   ROW_NUMBER() OVER (ORDER BY "total bonded SOL" DESC) AS rank FROM Tsf GROUP BY 1 ) WHERE rank <= 50 ORDER BY 3 ASC
15fe92f4-c755-4984-9689-d501a8ce3baa,NFTburn-full-ranking,WITH Txns AS ( SELECT   DISTINCT tx_id AS tx FROM solana.core.fact_events WHERE program_id = 'bondwbhv3sqgBgtzDZmyeohLrga26AcNiBvJ6jQzwgd'   AND block_timestamp >= '2024-01-25' ), LBoard AS (   SELECT     signers[0] AS signer,     COUNT(CASE WHEN program_id = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' THEN 1 END) AS "nfts burned",     ROW_NUMBER() OVER (ORDER BY "nfts burned" DESC) AS rank   FROM solana.core.fact_events   WHERE 1=1     AND tx_id IN (SELECT tx FROM Txns)     AND block_timestamp >= '2024-01-25'     AND succeeded   GROUP BY 1 ) SELECT   signer,   "nfts burned",   rank FROM LBoard ORDER BY 3 ASC
a71e19eb-419f-420b-ab64-660e44cf8399,SOLbond-full-ranking,WITH Txns AS ( SELECT   tx_id AS tx,   ARRAY_AGG(program_id) AS programs FROM solana.core.fact_events WHERE program_id = 'bondwbhv3sqgBgtzDZmyeohLrga26AcNiBvJ6jQzwgd'   AND block_timestamp >= '2024-01-25'   AND succeeded GROUP BY 1 ), Tsf AS (   SELECT     tx_id,     tx_from AS pledger,     MIN_BY(amount, index) AS bonded_sol   FROM solana.core.fact_transfers   WHERE 1=1     AND tx_id IN (SELECT tx FROM Txns WHERE NOT ARRAY_CONTAINS('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'::variant, programs))     AND mint = 'So11111111111111111111111111111111111111112'     AND block_timestamp >= '2024-01-25'   GROUP BY 1, 2 ) SELECT   pledger,   "total bonded SOL",   rank FROM ( SELECT   pledger,   ROUND(SUM(bonded_sol), 1) AS "total bonded SOL",   ROW_NUMBER() OVER (ORDER BY "total bonded SOL" DESC) AS rank FROM Tsf GROUP BY 1 ) ORDER BY 3 ASC
22237c70-5432-4a1c-8983-2a3a4db1094c,polymarket_general_insights,WITH condensed_order_fills AS (   SELECT     tx_hash,     timestamp,     CASE       WHEN array_contains(         'PositionSplit' :: variant,         array_agg(event_name)       ) THEN TRUE       ELSE FALSE     END AS is_pos_split,     CASE       WHEN array_contains(         'PositionsMerge' :: variant,         array_agg(event_name)       ) THEN TRUE       ELSE FALSE     END AS is_pos_merge,     CASE       WHEN (         is_pos_split         OR is_pos_merge       ) THEN array_agg(         CASE           WHEN event_name = 'OrderFilled' THEN decoded_log         END       )       ELSE array_agg(         CASE           WHEN event_name = 'OrderFilled'           AND event_index != idx_max THEN decoded_log         END       )     END AS d_logs   FROM     (       SELECT         tx_hash,         block_timestamp AS timestamp,         event_name,         event_index,         decoded_log,         max(event_index) OVER (PARTITION BY tx_hash) AS idx_max       FROM         polygon.core.ez_decoded_event_logs       WHERE         1 = 1         AND block_timestamp > sysdate() - interval '3 months'         AND contract_address IN (           '0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e',           '0xc5d563a36ae78145c45a50134d48a1215220f80a',           '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',           '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'         )         AND tx_status = 'SUCCESS'         AND event_name IN ('OrderFilled', 'PositionSplit', 'PositionsMerge')     )   GROUP BY     1,     2 ), fact_order_fills AS (   SELECT     timestamp,     CASE       WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:makerAssetId :: string       ELSE d_log.value:takerAssetId :: string     END AS market_id,     CASE       WHEN is_pos_split OR is_pos_merge       THEN          array_construct(           object_construct(             'address',             d_log.value:maker :: string,             'balance_change',             CASE               WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:takerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:makerAmountFilled :: float * pow(10, -6)             END           )         )        ELSE         array_construct(           object_construct(             'address',             d_log.value:maker :: string,             'balance_change',             CASE               WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:takerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:makerAmountFilled :: float * pow(10, -6)             END           ),           object_construct(             'address',             d_log.value:taker :: string,             'balance_change',             CASE               WHEN d_log.value:makerAssetId :: string = '0' THEN d_log.value:makerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:takerAmountFilled :: float * pow(10, -6)             END           )         )        END AS order_details   FROM     condensed_order_fills,     lateral flatten (input => d_logs) d_log ), -- then explode it: fact_bets AS (   SELECT     timestamp,     f.value:address AS address,     market_id,     f.value:balance_change AS balance_change,     CASE       WHEN balance_change < 0 THEN 'new_bet'       ELSE 'reduce_position'     END AS transfer_type   FROM     fact_order_fills,     lateral flatten (input => order_details) f ), eligible_addresses AS (   SELECT     address,     nb_trades   FROM     (       SELECT         address,         count(*) AS nb_trades       FROM         fact_bets       GROUP BY         address     ) fb     LEFT JOIN polygon.core.ez_token_transfers tsf ON fb.address = tsf.to_address   WHERE     1 = 1     AND block_timestamp > sysdate() - interval '6 months'     AND contract_address IN (       lower('0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359'),       lower('0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174')     )     AND nb_trades BETWEEN 5     AND 2000   GROUP BY     address,     nb_trades   HAVING     min(block_timestamp) BETWEEN sysdate() - interval '3 months'     AND sysdate() - interval '2 weeks' ), fact_payouts AS (   SELECT     block_timestamp AS timestamp,     decoded_log:redeemer :: string AS address,     'payout' AS transfer_type,     decoded_log:payout :: float * pow(10, -6) AS balance_change   FROM     polygon.core.ez_decoded_event_logs   WHERE     1 = 1     AND block_timestamp > sysdate() - interval '3 months'     AND contract_address IN (       '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',       '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'     )     AND event_name = 'PayoutRedemption'     AND tx_status = 'SUCCESS' ), general_fact_transfers AS (   SELECT     address,     nb_trades,     timestamp,     transfer_type,     market_id,     balance_change,     sum(balance_change) OVER (       PARTITION BY address       ORDER BY         timestamp     ) AS pnl   FROM     eligible_addresses     LEFT JOIN fact_bets USING(address) FULL     OUTER JOIN (       SELECT         *       FROM         eligible_addresses         LEFT JOIN fact_payouts USING(address)     ) USING(       address,       nb_trades,       timestamp,       balance_change,       transfer_type     )   WHERE     1 = 1     AND address != '0xc5d563a36ae78145c45a50134d48a1215220f80a'     AND address != '0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e' ), gambler_profiles AS (   SELECT     address,     sum(       CASE         WHEN balance_change < 0 THEN abs(balance_change)         ELSE 0       END     ) AS all_time_wager,     max_by(pnl, timestamp) / (       CASE         WHEN all_time_wager > 0 THEN all_time_wager         ELSE NULL       END     ) AS roi,     nb_trades,     CASE       WHEN nb_trades BETWEEN 5       AND 17 THEN 'one-off visitor'       WHEN nb_trades BETWEEN 18       AND 92 THEN 'weekly gambler'       WHEN nb_trades BETWEEN 93       AND 460 THEN 'daily gambler'       WHEN nb_trades BETWEEN 461       AND 2000 THEN 'HF gambler'     END AS gambler_profile   FROM     general_fact_transfers   GROUP BY     address,     nb_trades ), final_table AS (   SELECT     gambler_profile AS "gambler profile",     CASE       WHEN "gambler profile" = 'one-off visitor' THEN 1       WHEN "gambler profile" = 'weekly gambler' THEN 2       WHEN "gambler profile" = 'daily gambler' THEN 3       WHEN "gambler profile" = 'HF gambler' THEN 4     END AS rank,     count(*) AS "user count",     round(100 * avg(roi), 1) AS average_roi,     round(100 * median(roi), 1) AS median_roi,     round(       100 * count(         CASE           WHEN roi > 0 THEN 1         END       ) / "user count",       1     ) AS pct_profitable,     pct_profitable * ratio_to_report("user count") OVER () AS "overall % profitable"   FROM     eligible_addresses     LEFT JOIN gambler_profiles USING(address)   WHERE     1 = 1     AND all_time_wager >= 100   GROUP BY     gambler_profile ) SELECT   "gambler profile",   "user count",   average_roi::string || '%' AS "average ROI",   median_roi::string || '%' AS "median ROI",   pct_profitable::string || '%' AS "percent profitable",   round(     sum("overall % profitable") OVER (       ORDER BY         rank DESC     ),     1   ) AS "total % profitable (row 1)", FROM   final_table ORDER BY   rank
8addb00a-707f-4965-8f3f-d9cd179717ed,monetary-amber,SELECT 3 AS variable, CASE WHEN variable IS NOT NULL THEN 'yes' END WITH popcat_whales AS ( SELECT   owner,   SUM(balance - pre_balance) AS popcat_balance FROM solana.core.fact_token_balances WHERE 1=1 AND mint = '7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr' AND block_timestamp > sysdate() - interval '10 months' GROUP BY 1 ORDER BY 2 DESC LIMIT 200 ) , glorp_whales as ( SELECT   owner,   SUM(balance - pre_balance) AS glorp_balance FROM solana.core.fact_token_balances WHERE 1=1 AND block_timestamp > sysdate() - interval '7 months' AND mint = 'FkBF9u1upwEMUPxnXjcydxxVSxgr8f3k1YXbz7G7bmtA' AND owner IN (SELECT owner from popcat_whales) GROUP BY 1 ) SELECT   owner,   popcat_balance,   glorp_balance FROM glorp_whales INNER JOIN popcat_whales USING(owner) ORDER BY 3 DESC
a305d0f9-08d8-4e72-98fb-8eb1fbcc4315,polymarket_individual_charts,WITH fact_individual_data AS (   SELECT   FROM (   SELECT     livequery.live.udf_api(       'https://flipsidecrypto.xyz/api/v1/queries/f250675f-ec6d-4f11-a801-eed03a2f77df/data/latest'     ) AS response   ), lateral flatten (input => response.data) )
7e1776a2-e8fd-430f-bf03-988391ad9eef,amateur-salmon,select * from solana.defi.fact_token_mint_actions where mint = '23CTZMjEYNNZUE4itfn3iv6kgM4xn7X7dx1kVX1Gr8Xi' order by block_timestamp desc
a2424c22-4f24-4350-b9b3-7963c0330596,supreme-turquoise,select * from values (1.1125,2.03,3), (1.1,1.55,5), (1.1,1.8,4), (1,1,2) as t(x,y,z)
b650c237-663b-40ab-a8a4-e7e349aeba6f,PARCLv3_money-flows,WITH       -- CTE with all transfers since v3 kickoff:   Transfers AS (     SELECT       block_timestamp,       tx_id,       signers[0] AS signer,       tx_from,       tx_to,       amount, --             Below we identify the nature of money flows in and out Exchange 1 based on the name of the ix called.       ARRAY_CONTAINS('Program log: Instruction: DepositMargin'::variant, log_messages) AS is_margin_deposit,  -- margin deposits use the DepositMargin ix       ARRAY_CONTAINS('Program log: Instruction: AddLiquidity'::variant, log_messages) AS is_lp_deposit, -- depositing to the LP uses the AddLiquidity ix       ARRAY_CONTAINS('Program log: Instruction: ProcessSettlementRequests'::variant, log_messages) AS is_withdrawal -- withdrawing margin uses ProcessSettlementRequests ix     FROM solana.core.fact_transfers     JOIN solana.core.fact_transactions USING(block_timestamp, tx_id)     WHERE (tx_from = '82dGS7Jt4Km8ZgwZVRsJ2V6vPXEhVdgDaMP7cqPGG1TW' -- this is the Exchange 1 address that every tx (margin/liquidity deposit or withdrawal) goes through.         OR tx_to = '82dGS7Jt4Km8ZgwZVRsJ2V6vPXEhVdgDaMP7cqPGG1TW')       AND (ARRAY_CONTAINS('Program log: Instruction: DepositMargin'::variant, log_messages)         OR ARRAY_CONTAINS('Program log: Instruction: AddLiquidity'::variant, log_messages)         OR ARRAY_CONTAINS('Program log: Instruction: ProcessSettlementRequests'::variant, log_messages)       )       AND block_timestamp >= '2024-04-15'       AND succeeded   ),         -- CTE with all trades & liq withdrawals since v3 kickoff:   TradesLiqRemv AS (     SELECT       DISTINCT       block_timestamp,       tx_id,       signers[0] AS signer,       account_keys       --ARRAY_CONTAINS('Program log: Instruction: ModifyPosition'::variant, log_messages) AS is_trade,       --ARRAY_CONTAINS('Program log: Instruction: RemoveLiquidity'::variant, log_messages) AS is_lp_withdrawal     FROM solana.core.fact_transactions     JOIN solana.core.fact_events USING(block_timestamp, tx_id, signers)     WHERE program_id = '3parcLrT7WnXAcyPfkCz49oofuuf2guUKkjuFkAhZW8Y'       -- "ModifyPosition" ix is called whenever a trade is made (modifying an open postion or opening new/closing entire position).       -- AND (ARRAY_CONTAINS('Program log: Instruction: ModifyPosition'::variant, log_messages)       -- removing funds from LP uses RemoveLiquidity ix       AND ARRAY_CONTAINS('Program log: Instruction: RemoveLiquidity'::variant, log_messages)       --)       AND block_timestamp >= '2024-04-15'       AND succeeded   )         --LiqRemoved AS (     SELECT       tsf.block_timestamp AS block_timestamp,       tsf.tx_id AS tx_id,       --tsf.signer AS signer,       tsf.tx_to AS tx_to,       amount,       TRUE AS is_lp_withdrawal     FROM TradesLiqRemv liq     INNER JOIN Transfers tsf ON tsf.tx_to = liq.signer     WHERE 1=1       --AND liq.is_lp_withdrawal       AND tsf.is_withdrawal       AND tsf.tx_from = '82dGS7Jt4Km8ZgwZVRsJ2V6vPXEhVdgDaMP7cqPGG1TW'       -- The ProcessSettlementRequests transaction happens 24 hours later, usually within a 15-minute window:       AND tsf.block_timestamp BETWEEN DATEADD('day', +1 , liq.block_timestamp) AND DATEADD('minute', +15, DATEADD('day', +1 , liq.block_timestamp))   --)   --Traders AS (   --  SELECT   --    DATE_TRUNC('day', block_timestamp) AS day,   --    COUNT(DISTINCT signer) AS total_active_traders,   --    COUNT(DISTINCT tx_id) AS trades,                  --    SUM(trades) OVER (ORDER BY day) AS cumulative_trades   --  FROM TradesLiqRemv   --  WHERE is_trade   --  GROUP BY day   --),         --Dau AS (   --  SELECT    --    day,   --    COUNT(DISTINCT signer) AS dau   --  FROM (   --    SELECT    --      signer,    --      DATE_TRUNC('day', block_timestamp) AS day   --    FROM Transfers   --    FULL OUTER JOIN TradesLiqRemv USING(signer, block_timestamp)   --  )   --  GROUP BY day   --),      -- weekly deposits (margin & LP), withdrawals (margin & LP), net flow and TVL (cumulative net flow).   --ProtocolStats AS (   --SELECT   --  --DATE_TRUNC('day', block_timestamp) AS day,   --  DATE_TRUNC('week', day) AS week,   --  ROUND(SUM(CASE WHEN is_margin_deposit THEN amount END)) AS margin_deposits_USDC,   --  ROUND(SUM(CASE WHEN is_lp_deposit THEN amount END)) AS LP_deposits_USDC,   --  --margin_deposits_USDC + LP_deposits_USDC AS total_deposits_USDC,   --  - ROUND(SUM(CASE WHEN is_withdrawal AND (liq.is_lp_withdrawal IS NULL) THEN amount END)) AS margin_withdrawals_USDC,   --  - COALESCE(ROUND(SUM(CASE WHEN liq.is_lp_withdrawal THEN amount END)), 0) AS LP_withdrawals_USDC,   --  --margin_withdrawals_USDC + LP_withdrawals_USDC AS total_withdrawals_USDC,   --  margin_deposits_USDC + LP_deposits_USDC + margin_withdrawals_USDC + LP_withdrawals_USDC AS weekly_net_flow_USDC   --  --SUM(weekly_net_flow_USDC) OVER (ORDER BY day) AS TVL_USDC  -- the TVL is actually the balance of Exchange 1, pretty straightforward.   --  --CASE WHEN week = day THEN TVL_USDC END AS weekly_TVL_USDC   --FROM Transfers tsf   --LEFT JOIN LiqRemoved liq USING(block_timestamp, tx_id, tx_to, amount)   --GROUP BY week   --ORDER BY week DESC --SELECT * --FROM ProtocolStats --JOIN Dau USING(day) --JOIN Traders USING(day) --ORDER BY day DESC
f250675f-ec6d-4f11-a801-eed03a2f77df,polymarket_individual_study,WITH condensed_order_fills AS (   SELECT     tx_hash,     timestamp,     CASE       WHEN array_contains(         'PositionSplit' :: variant,         array_agg(event_name)       ) THEN TRUE ELSE FALSE      END AS is_pos_split,     CASE       WHEN array_contains(         'PositionsMerge' :: variant,         array_agg(event_name)       ) THEN TRUE ELSE FALSE      END AS is_pos_merge,     CASE WHEN (is_pos_split OR is_pos_merge) THEN       array_agg(         CASE           WHEN event_name = 'OrderFilled' THEN decoded_log         END       )       ELSE array_agg(         CASE           WHEN event_name = 'OrderFilled' AND event_index != idx_max THEN decoded_log         END       )     END AS d_logs   FROM     (       SELECT         tx_hash,         block_timestamp AS timestamp,         event_name,         event_index,         decoded_log,         max(event_index) OVER (PARTITION BY tx_hash) AS idx_max       FROM         polygon.core.ez_decoded_event_logs       WHERE         1 = 1         AND block_timestamp > sysdate() - interval '3 months'         AND contract_address IN (           '0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e',           '0xc5d563a36ae78145c45a50134d48a1215220f80a',           '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',           '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'         )         AND tx_status = 'SUCCESS'         AND event_name IN ('OrderFilled', 'PositionSplit', 'PositionsMerge')     )   GROUP BY     1,     2 ) -- select * from condensed_order_fills where tx_hash = '0x79fe591aac643f3182d043b06e258cd2447646b71e74d56658f7afecd4774e91' -- select * from polygon.core.ez_decoded_event_logs WHERE tx_hash = '0xd43fbeb62c0c505c5920515b6dd9557e96d62d63e8ee586bef644d8818609b09' order by event_index , fact_order_fills AS (   SELECT     timestamp,     CASE       WHEN is_pos_split OR is_pos_merge       THEN          array_construct(           object_construct(             'address',             d_log.value:maker :: string,             'balance_change',             CASE               WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:takerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:makerAmountFilled :: float * pow(10, -6)             END           )         )        ELSE         array_construct(           object_construct(             'address',             d_log.value:maker :: string,             'balance_change',             CASE               WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:takerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:makerAmountFilled :: float * pow(10, -6)             END           ),           object_construct(             'address',             d_log.value:taker :: string,             'balance_change',             CASE               WHEN d_log.value:makerAssetId :: string = '0' THEN d_log.value:makerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:takerAmountFilled :: float * pow(10, -6)             END           )         )        END AS order_details   FROM     condensed_order_fills,     lateral flatten (input => d_logs) d_log ), -- then explode it: fact_bets AS (   SELECT     timestamp,     f.value:address AS address,     f.value:balance_change AS balance_change,     CASE       WHEN balance_change < 0 THEN 'new_bet'       ELSE 'reduce_position'     END AS transfer_type   FROM     fact_order_fills,     lateral flatten (input => order_details) f ) -- select * from fact_bets where address = lower('0x60D1e1b628D5EE360C2f3D172A24baAc77e38e71') order by timestamp , eligible_addresses AS (   SELECT     address,     nb_bets,     nb_trades   FROM     (       SELECT         address,         count(CASE WHEN transfer_type = 'new_bet' THEN 1 END) AS nb_bets,         count(*) AS nb_trades       FROM         fact_bets       GROUP BY         address     ) fb     LEFT JOIN polygon.core.ez_token_transfers tsf ON fb.address = tsf.to_address     WHERE       1 = 1       AND block_timestamp > sysdate() - interval '6 months'       AND contract_address IN (         lower('0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359'),         lower('0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174')       )       AND nb_bets BETWEEN 25 AND 1000       AND nb_bets BETWEEN 0.2 * nb_trades AND 0.7 * nb_trades       AND nb_trades <= 2000        -- we're excluding the one-off visitors category here   GROUP BY     address,     nb_bets,     nb_trades   HAVING     min(block_timestamp) BETWEEN sysdate() - interval '3 months'     AND sysdate() - interval '2 weeks' -- for pnl numbers to make sense, we analyse new wallets less than 3 months old. ), fact_payouts AS (   SELECT     block_timestamp AS timestamp,     decoded_log:redeemer :: string AS address,     'payout' AS transfer_type,     decoded_log:payout :: float * pow(10, -6) AS balance_change   FROM     polygon.core.ez_decoded_event_logs   WHERE     1 = 1     AND block_timestamp > sysdate() - interval '3 months'     AND contract_address IN (       '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',       '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'     )     AND event_name = 'PayoutRedemption'     AND tx_status = 'SUCCESS' ), general_fact_transfers AS (   SELECT     address,     timestamp,     nb_bets,     nb_trades,     transfer_type,     balance_change,     sum(balance_change) OVER (       PARTITION BY address       ORDER BY         timestamp     ) AS pnl   FROM     eligible_addresses     LEFT JOIN fact_bets USING(address)      FULL OUTER JOIN (       SELECT         *       FROM         eligible_addresses         LEFT JOIN fact_payouts USING(address)     ) USING(       address,       nb_bets,       nb_trades,       timestamp,       balance_change,       transfer_type     )   WHERE     1 = 1     AND address != '0xc5d563a36ae78145c45a50134d48a1215220f80a'     AND address != '0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e' ), gambler_profiles AS (   SELECT     address,     sum(CASE WHEN balance_change < 0 THEN abs(balance_change) ELSE 0 END) AS all_time_wager,     median(CASE WHEN transfer_type = 'new_bet' THEN abs(balance_change) END) AS median_wager,     round(max_by(pnl, timestamp) / (CASE WHEN all_time_wager > 0 THEN all_time_wager ELSE NULL END), 2) AS roi,     CASE       WHEN nb_trades BETWEEN 25 AND 92 THEN 'weekly gambler'       WHEN nb_trades BETWEEN 93 AND 460 THEN 'daily gambler'       WHEN nb_trades BETWEEN 461 AND 2000 THEN 'HF gambler'     END AS gambler_profile   FROM general_fact_transfers   GROUP BY address, nb_bets, nb_trades ), best_worst_gamblers AS (   SELECT     gambler_profile,     max_by(address, roi) AS best,     min_by(address, roi) AS worst   FROM gambler_profiles   WHERE all_time_wager >= 100     AND median_wager > 0.1   GROUP BY 1 ) --   FROM ( --     SELECT --       gambler_profile, --       max(CASE WHEN (roi BETWEEN 5 AND 30) AND all_time_wager >= 100 THEN roi END) AS max_roi, --       min(CASE WHEN (roi BETWEEN -0.8 AND -0.4) AND all_time_wager >= 100 THEN roi END) AS min_roi --     FROM gambler_profiles --     GROUP BY 1 --   ) a --   LEFT JOIN gambler_profiles gpmax ON a.gambler_profile = gpmax.gambler_profile AND a.max_roi = gpmax.roi --   LEFT JOIN gambler_profiles gpmin ON a.gambler_profile = gpmin.gambler_profile AND a.min_roi = gpmin.roi -- ) -- select * from best_worst_gamblers bw left join general_fact_transfers fct on bw.best = fct.address where gambler_profile = 'weekly gambler' order by timestamp , b_w_flattened AS (     SELECT       'best ' || gambler_profile AS profile,       best AS address     FROM best_worst_gamblers        UNION ALL        SELECT       'worst ' || gambler_profile AS profile,       worst AS address     FROM best_worst_gamblers ) , selected_gambler_metrics AS (   SELECT     *     -- , lag(rolling_bet, 1, 1) OVER (     --         PARTITION BY address, transfer_type     --         ORDER BY     --           timestamp     --   ) AS prev_r_bet     -- , lag(rolling_pnl, 1, 1) OVER (     --     PARTITION BY address, transfer_type     --     ORDER BY     --       timestamp     --   ) AS prev_r_pnl     -- , rolling_bet - prev_r_bet     --   AS r_bet_delta     , abs(rolling_bet / rolling_pnl) AS bet_pnl_delta   FROM     (       SELECT         address,         timestamp,         transfer_type,         pnl         , avg(             CASE               WHEN transfer_type = 'new_bet' THEN pnl             END           ) OVER (             PARTITION BY address,             transfer_type             ORDER BY               timestamp ROWS BETWEEN 3 PRECEDING               AND CURRENT ROW           ) AS rolling_pnl         , avg(             CASE               WHEN transfer_type = 'new_bet' THEN abs(balance_change)             END           ) OVER (             PARTITION BY address,             transfer_type             ORDER BY               timestamp ROWS BETWEEN 3 PRECEDING               AND CURRENT ROW           ) AS rolling_bet       FROM         b_w_flattened         LEFT JOIN general_fact_transfers           USING(address)       WHERE 1=1         AND transfer_type = 'new_bet'     ) ) , b_w_stats AS (   SELECT     profile,     pnl,     bet_pnl_delta,     CASE WHEN profile = 'best weekly gambler' THEN row_number() OVER (PARTITION BY profile ORDER BY timestamp) END AS best_weekly_idx,     CASE WHEN profile = 'best daily gambler' THEN row_number() OVER (PARTITION BY profile ORDER BY timestamp) END AS best_daily_idx,     CASE WHEN profile = 'best HF gambler' THEN row_number() OVER (PARTITION BY profile ORDER BY timestamp) END AS best_HF_idx,     CASE WHEN profile = 'worst weekly gambler' THEN row_number() OVER (PARTITION BY profile ORDER BY timestamp) END AS worst_weekly_idx,     CASE WHEN profile = 'worst daily gambler' THEN row_number() OVER (PARTITION BY profile ORDER BY timestamp) END AS worst_daily_idx,     CASE WHEN profile = 'worst HF gambler' THEN row_number() OVER (PARTITION BY profile ORDER BY timestamp) END AS worst_HF_idx   FROM b_w_flattened   LEFT JOIN selected_gambler_metrics USING (address)   WHERE bet_pnl_delta IS NOT NULL ) , pnl_table AS (   SELECT *   FROM (     SELECT       profile || ' pnl' AS profile,       pnl,       best_weekly_idx,       best_daily_idx,       best_HF_idx,             worst_weekly_idx,       worst_daily_idx,       worst_HF_idx     FROM b_w_stats   ) pivot(max(pnl) FOR profile IN(       'best weekly gambler pnl',       'best daily gambler pnl',       'best HF gambler pnl',       'worst weekly gambler pnl',       'worst daily gambler pnl',       'worst HF gambler pnl'     )) AS p(       best_weekly_idx,       best_daily_idx,       best_HF_idx,             worst_weekly_idx,       worst_daily_idx,       worst_HF_idx,       best_weekly_pnl,       best_daily_pnl,       best_hf_pnl,       worst_weekly_pnl,       worst_daily_pnl,       worst_hf_pnl     ) ) , delta_table AS (   SELECT *   FROM (     SELECT       profile || ' delta' AS profile,       sign(bet_pnl_delta) * ln(1 + abs(bet_pnl_delta)) AS ln_bet_pnl_delta,       best_weekly_idx,       best_daily_idx,       best_HF_idx,             worst_weekly_idx,       worst_daily_idx,       worst_HF_idx     FROM b_w_stats   ) pivot(max(ln_bet_pnl_delta) FOR profile IN(       'best weekly gambler delta',       'best daily gambler delta',       'best HF gambler delta',       'worst weekly gambler delta',       'worst daily gambler delta',       'worst HF gambler delta'     )) AS p(       best_weekly_idx,       best_daily_idx,       best_HF_idx,             worst_weekly_idx,       worst_daily_idx,       worst_HF_idx,       best_weekly_delta,       best_daily_delta,       best_hf_delta,       worst_weekly_delta,       worst_daily_delta,       worst_hf_delta     ) -- order by best_daily_idx ) SELECT * FROM pnl_table LEFT JOIN (SELECT best_weekly_delta, best_weekly_idx FROM delta_table) a USING(best_weekly_idx) LEFT JOIN (SELECT best_daily_delta, best_daily_idx FROM delta_table) b USING(best_daily_idx) LEFT JOIN (SELECT best_HF_delta, best_HF_idx FROM delta_table) c USING(best_HF_idx) LEFT JOIN (SELECT worst_weekly_delta, worst_weekly_idx FROM delta_table) d USING(worst_weekly_idx) LEFT JOIN (SELECT worst_daily_delta, worst_daily_idx FROM delta_table) e USING(worst_daily_idx) LEFT JOIN (SELECT worst_HF_delta, worst_HF_idx FROM delta_table) f USING(worst_HF_idx) WHERE   (best_weekly_idx >= 3 OR best_weekly_idx IS NULL)   AND (best_daily_idx >= 3 OR best_daily_idx IS NULL)   AND (best_HF_idx >= 3 OR best_HF_idx IS NULL)       AND (worst_weekly_idx >= 3 OR worst_weekly_idx IS NULL)   AND (worst_daily_idx >= 3 OR worst_daily_idx IS NULL)   AND (worst_HF_idx >= 3 OR worst_HF_idx IS NULL) order by best_weekly_idx
9e5b7344-92ac-43c0-a61a-1bac5c129a37,polymarket_correlation_heatmap,WITH condensed_order_fills AS (   SELECT     tx_hash,     timestamp,     CASE       WHEN array_contains(         'PositionSplit' :: variant,         array_agg(event_name)       ) THEN TRUE ELSE FALSE      END AS is_pos_split,     CASE       WHEN array_contains(         'PositionsMerge' :: variant,         array_agg(event_name)       ) THEN TRUE ELSE FALSE      END AS is_pos_merge,     CASE WHEN (is_pos_split OR is_pos_merge) THEN       array_agg(         CASE           WHEN event_name = 'OrderFilled' THEN decoded_log         END       )       ELSE array_agg(         CASE           WHEN event_name = 'OrderFilled' AND event_index != idx_max THEN decoded_log         END       )     END AS d_logs   FROM     (       SELECT         tx_hash,         block_timestamp AS timestamp,         event_name,         event_index,         decoded_log,         max(event_index) OVER (PARTITION BY tx_hash) AS idx_max       FROM         polygon.core.ez_decoded_event_logs       WHERE         1 = 1         AND block_timestamp > sysdate() - interval '3 months'         AND contract_address IN (           '0x4bfb41d5b3570defd03c39a9a4d8de6bd8b8982e',           '0xc5d563a36ae78145c45a50134d48a1215220f80a',           '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',           '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'         )         AND tx_status = 'SUCCESS'         AND event_name IN ('OrderFilled', 'PositionSplit', 'PositionsMerge')     )   GROUP BY     1,     2 ), fact_order_fills AS (   SELECT     timestamp,     CASE       WHEN is_pos_split OR is_pos_merge       THEN          array_construct(           object_construct(             'address',             d_log.value:maker :: string,             'balance_change',             CASE               WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:takerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:makerAmountFilled :: float * pow(10, -6)             END           )         )        ELSE         array_construct(           object_construct(             'address',             d_log.value:maker :: string,             'balance_change',             CASE               WHEN d_log.value:takerAssetId :: string = '0' THEN d_log.value:takerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:makerAmountFilled :: float * pow(10, -6)             END           ),           object_construct(             'address',             d_log.value:taker :: string,             'balance_change',             CASE               WHEN d_log.value:makerAssetId :: string = '0' THEN d_log.value:makerAmountFilled :: float * pow(10, -6)               ELSE - d_log.value:takerAmountFilled :: float * pow(10, -6)             END           )         )        END AS order_details   FROM     condensed_order_fills,     lateral flatten (input => d_logs) d_log ), -- then explode it: fact_bets AS (   SELECT     timestamp,     f.value:address AS address,     f.value:balance_change AS balance_change,     CASE       WHEN balance_change < 0 THEN 'new_bet'       ELSE 'reduce_position'     END AS transfer_type   FROM     fact_order_fills,     lateral flatten (input => order_details) f ), eligible_addresses AS (   SELECT     address,     nb_bets,     nb_trades   FROM     (       SELECT         address,         count(CASE WHEN transfer_type = 'new_bet' THEN 1 END) AS nb_bets,         count(*) AS nb_trades       FROM         fact_bets       GROUP BY         address     ) fb     LEFT JOIN polygon.core.ez_token_transfers tsf ON fb.address = tsf.to_address     WHERE       1 = 1       AND block_timestamp > sysdate() - interval '6 months'       AND contract_address IN (         lower('0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359'),         lower('0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174')       )       AND nb_bets BETWEEN 24 AND 1000       AND nb_trades BETWEEN 30 AND 2000      -- we're excluding the one-off visitors category here   GROUP BY     address,     nb_bets,     nb_trades   HAVING     min(block_timestamp) BETWEEN sysdate() - interval '3 months'     AND sysdate() - interval '2 weeks' -- for pnl numbers to make sense, we analyse new wallets less than 3 months old. ), fact_payouts AS (   SELECT     block_timestamp AS timestamp,     decoded_log:redeemer :: string AS address,     'payout' AS transfer_type,     decoded_log:payout :: float * pow(10, -6) AS balance_change   FROM     polygon.core.ez_decoded_event_logs   WHERE     1 = 1     AND block_timestamp > sysdate() - interval '3 months'     AND contract_address IN (       '0xd91e80cf2e7be2e162c6513ced06f1dd0da35296',       '0x4d97dcd97ec945f40cf65f87097ace5ea0476045'     )     AND event_name = 'PayoutRedemption'     AND tx_status = 'SUCCESS' ), general_fact_transfers AS (   SELECT     address,     timestamp,     nb_bets,     nb_trades,     transfer_type,     balance_change,     sum(balance_change) OVER (       PARTITION BY address       ORDER BY         timestamp     ) AS pnl   FROM     eligible_addresses     LEFT JOIN fact_bets USING(address) FULL     OUTER JOIN (       SELECT         *       FROM         eligible_addresses         LEFT JOIN fact_payouts USING(address)     ) USING(       address,       nb_bets,       timestamp,       balance_change,       transfer_type     )   WHERE     1 = 1     AND address != '0xc5d563a36ae78145c45a50134d48a1215220f80a' ) , fact_gambler_metrics AS (   SELECT     *     -- , lag(rolling_bet, 1, 1) OVER (     --         PARTITION BY address, transfer_type     --         ORDER BY     --           timestamp     --   ) AS prev_r_bet     , lag(rolling_pnl, 1, 1) OVER (         PARTITION BY address, transfer_type         ORDER BY           timestamp       ) AS prev_r_pnl     -- , (rolling_bet - prev_r_bet) / (     --   CASE WHEN prev_r_bet != 0 THEN prev_r_bet ELSE 1 END     -- ) AS r_bet_delta     , (rolling_pnl - prev_r_pnl) / (       CASE WHEN prev_r_pnl != 0 THEN prev_r_pnl ELSE 1 END       ) AS pnl_delta     , CASE WHEN prev_r_pnl < 0 THEN - pnl_delta ELSE pnl_delta END AS r_pnl_delta     , abs(rolling_bet / (CASE WHEN rolling_pnl BETWEEN -1 AND 1 THEN 1 ELSE rolling_pnl END)) AS bet_pnl_delta   FROM     (       SELECT         *         , avg(           CASE             WHEN transfer_type = 'new_bet' THEN pnl           END         ) OVER (           PARTITION BY address,           transfer_type           ORDER BY             timestamp ROWS BETWEEN 3 PRECEDING             AND CURRENT ROW         ) AS rolling_pnl         , avg(           CASE             WHEN transfer_type = 'new_bet' THEN abs(balance_change)           END         ) OVER (           PARTITION BY address,           transfer_type           ORDER BY             timestamp ROWS BETWEEN 3 PRECEDING             AND CURRENT ROW         ) AS rolling_bet       FROM         general_fact_transfers     ) ), gambler_profiles AS (   SELECT     address     , nb_bets     , nb_trades     , sum(         CASE           WHEN balance_change < 0 THEN abs(balance_change)           ELSE 0         END       ) AS all_time_wager     , median(CASE WHEN transfer_type = 'new_bet' THEN abs(balance_change) END) AS median_wager     , max_by(pnl, timestamp) / (         CASE           WHEN all_time_wager > 0 THEN all_time_wager           ELSE NULL         END       ) AS gambler_roi     , CASE         WHEN nb_trades BETWEEN 25 AND 92 THEN 'weekly gambler'         WHEN nb_trades BETWEEN 93 AND 460 THEN 'daily gambler'         WHEN nb_trades BETWEEN 461 AND 2000 THEN 'HF gambler'       END AS gambler_profile   FROM     general_fact_transfers   GROUP BY     address,     nb_bets,     nb_trades ), fact_rbet_pnl AS (   SELECT     address,     bet_pnl_delta,     pnl,     r_pnl_delta   FROM     fact_gambler_metrics   WHERE     1 = 1     AND bet_pnl_delta IS NOT NULL ), correlations AS (   SELECT     *   FROM (     (       SELECT         address,         round(corr(bet_pnl_delta, pnl), 1) AS corr_pnl_inc       FROM         fact_rbet_pnl       WHERE         1 = 1         AND r_pnl_delta >= 0       GROUP BY         address     ) a     INNER JOIN (       SELECT         address,         round(corr(bet_pnl_delta, pnl), 1) AS corr_pnl_dec       FROM         fact_rbet_pnl       WHERE         1 = 1         AND r_pnl_delta < 0       GROUP BY         address     ) b USING(address)   ) ), fact_corr_pnl AS (   SELECT     profile,     corr_pnl_inc AS x,     corr_pnl_dec AS y,     roi   FROM (     SELECT       *,       gambler_profile AS profile,       gambler_roi AS roi     FROM correlations c     INNER JOIN gambler_profiles USING(address)   )   WHERE     1 = 1     AND corr_pnl_inc IS NOT NULL     AND corr_pnl_dec IS NOT NULL     AND roi <= 10     AND all_time_wager >= 100     AND median_wager > 0.1 ), sequence AS (   SELECT *   FROM (SELECT -1 + (row_number() OVER (ORDER BY (SELECT NULL)) - 1) * 0.1 AS value       FROM table(generator(rowcount => 11)))      UNION ALL   SELECT *      FROM (SELECT (row_number() OVER (ORDER BY (SELECT NULL))) * 0.1 AS value       FROM table(generator(rowcount => 10))) ), grid AS ( SELECT * FROM (SELECT value AS x FROM sequence) a CROSS JOIN (SELECT value AS y FROM sequence) b ) SELECT   x,   y,   round(avg(CASE WHEN profile = 'weekly gambler' THEN roi END), 2) AS avg_roi_weekly,   round(avg(CASE WHEN profile = 'daily gambler' THEN roi END), 2) AS avg_roi_daily,   round(avg(CASE WHEN profile = 'HF gambler' THEN roi END), 2) AS avg_roi_HF,   count(CASE WHEN profile = 'weekly gambler' AND roi IS NOT NULL THEN 1 END) AS weekly_gamblers,   count(CASE WHEN profile = 'daily gambler' AND roi IS NOT NULL THEN 1 END) AS daily_gamblers,   count(CASE WHEN profile = 'HF gambler' AND roi IS NOT NULL THEN 1 END) AS HF_gamblers FROM grid LEFT JOIN fact_corr_pnl   USING(x, y) GROUP BY x, y ORDER BY x, y
82cd6a4e-49f0-4573-8cc0-8d7764bac7c0,geographical-turquoise,WITH daily_txn AS ( SELECT   block_timestamp::date as day,   EXTRACT(month FROM block_timestamp) as month,   COUNT(*) as n_txn FROM ethereum.core.fact_transactions WHERE block_timestamp BETWEEN '2024-01-01' AND '2024-07-31' GROUP BY 1,2 ), months (month, month_name) AS ( SELECT * FROM VALUES (1,'January'), (2,'February'), (3,'March'), (4,'April'), (5,'May'), (6,'June'), (7,'July') ) SELECT   month,   month_name,   MAX_BY(day, n_txn),   MAX(n_txn) AS highest_daily_txn FROM daily_txn JOIN months USING(month) GROUP BY 1,2 ORDER BY 1 -- SELECT --   DATE_TRUNC('month', block_timestamp) AS datetrunc, --   EXTRACT(month FROM block_timestamp) AS extract -- FROM ethereum.core.fact_transactions -- LIMIT 1
d51bfe62-d817-47a5-917e-7888189922f5,ambitious-copper,select block_timestamp , tx_hash , to_address , name , category , value from monad.testnet.fact_transactions  left join (select * from $query('ae1af2d4-a9d1-4cad-a095-6c6a6c33fae4')) on to_address = address where from_address = lower('0x80b2437B57baf818d4439104bcf768229689b161') order by block_timestamp desc
dfbf1c66-f3c3-473c-ba9c-ee3494436cc6,near-lime,select * from monad.testnet.dim_contracts  where address = '0xa4394644a3362dbc6832590cde9d3c7e43c97d47'  or address = '0xd6508474148b83ac4fd874c8380f5288d37aeb7d' or address = '0x2e59ba783afb3c32f121620664de0dc8f6cd834b'
f0f4b3c1-288c-4465-83d4-4bacf4106dc6,monetary-silver,SELECT * FROM VALUES ('arbitrum', 7, 8), ('base', 16, 7), ('solana', 20, 4) AS t(chain, dest, source)
34676064-f3f3-4f70-b8df-0ec32f8f169a,absolute-harlequin,select * from solana.defi.ez_dex_swaps where 1=1 and swap_program = {{swap_prog}} and block_timestamp > sysdate() - interval '50 minutes' order by block_timestamp desc
253669fe-a85e-4983-86aa-3308f9248382,electrical-bronze,select   row_number() over (order by (select null)) as x,   row_number() over (order by (select null)) as y,   row_number() over (order by (select null)) as z from   table(generator(rowcount => 261))
48fde928-e0a9-45d4-af18-00b1c4416f79,polymarket_overall_gamblers_insights,WITH fact_gamblers_activity AS (   SELECT *    FROM (     SELECT livequery.live.udf_api('https://flipsidecrypto.xyz/studio/queries/22237c70-5432-4a1c-8983-2a3a4db1094c/data/latest') AS response     ), lateral flatten (input => response:data)   LIMIT 20 )
71b6b705-3649-419f-898b-8e16f1a6e9b2,charming-copper,-- SELECT * -- from berachain.testnet.fact_transactions sample (25 rows) -- where block_timestamp >= sysdate() - interval '7 days' WITH counts AS (   SELECT     COUNT(*) as txns,     COUNT(CASE WHEN status='SUCCESS' THEN 1 END) as successes   FROM ethereum.core.fact_transactions   WHERE block_timestamp > sysdate() - interval '6 months' ) SELECT   ROUND(100 * successes/txns, 2) AS "ethereum txn success rate" FROM counts
fc0e5a1b-34b6-44f3-b00d-eaf3ad2be0a4,safe-copper,WITH sol_mints AS (   SELECT     DATE_TRUNC('day', block_timestamp) AS day,     SUM(mint_amount)*pow(10, -6) AS mints   FROM solana.defi.fact_token_mint_actions   WHERE mint = '2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo'     AND block_timestamp >= '2023-07-01'     AND succeeded   GROUP BY 1 ), sol_burns AS (   SELECT     DATE_TRUNC('day', block_timestamp) AS day,     SUM(burn_amount)*pow(10, -6) AS burns   FROM solana.defi.fact_token_burn_actions   WHERE mint = '2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo'     AND block_timestamp >= '2023-07-01'     AND succeeded   GROUP BY 1 ), solana_supply AS (   SELECT     day,     COALESCE(mints, 0) - COALESCE(burns, 0) AS sol_net_flow   FROM sol_mints   FULL OUTER JOIN sol_burns USING(day) ), eth_supply AS (   SELECT     DATE_TRUNC('day', block_timestamp) AS day,     (COALESCE(SUM(CASE WHEN from_address='0x0000000000000000000000000000000000000000' THEN raw_amount END), 0) - COALESCE(SUM(CASE WHEN to_address='0x0000000000000000000000000000000000000000' THEN raw_amount END), 0))*pow(10, -6) AS eth_net_flow   FROM ethereum.core.fact_token_transfers   WHERE 1=1     AND contract_address = '0x6c3ea9036406852006290770bedfcaba0e23a0e8'     AND block_timestamp >= '2023-07-01'   GROUP BY 1 ) SELECT   day,   COALESCE(sol_net_flow, 0) + COALESCE(eth_net_flow, 0) AS net_flow,   SUM(net_flow) OVER (ORDER BY day) AS total_pyusd_supply FROM solana_supply FULL OUTER JOIN eth_supply USING(day) ORDER BY day DESC -- SELECT * FROM ethereum.core.fact_token_transfers WHERE tx_hash='0x1aad1a6d6a48c29cb249675f98bf57062e70bfc9b353e3b0379337e11d74351a'
38a47cb2-9289-4827-a765-a49c13b7bb78,gentle-coral,-- WITH balances AS ( --   SELECT --     user_address, --     MAX_BY(balance, block_timestamp) AS usdc_balance --   FROM ethereum.core.fact_token_balances --   WHERE contract_address = lower('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48') --   GROUP BY 1 -- ) -- SELECT --   SUM(usdc_balance) AS usdc_supply -- FROM balances -- WITH -- mints AS ( --   SELECT --     SUM(raw_amount_precise)*pow(10, -6) as usdc_mints --   FROM ethereum.core.fact_token_transfers --   WHERE contract_address = lower('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48') --     AND from_address = '0x0000000000000000000000000000000000000000' --     -- AND to_address = lower('0x55FE002aefF02F77364de339a1292923A15844B8') -- ), -- burns AS ( --   SELECT --     SUM(raw_amount_precise)*pow(10, -6) as usdc_burns --   FROM ethereum.core.fact_token_transfers --   WHERE contract_address = lower('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48') --     AND to_address = '0x0000000000000000000000000000000000000000' -- ) -- SELECT --   usdc_mints - usdc_burns AS usdc_supply -- FROM mints, burns WITH week_series AS (   SELECT      dateadd(         week,         '-' || row_number() over (order by null),         dateadd(week, '+1', '2024-08-26')       ) as week   FROM TABLE(GENERATOR(ROWCOUNT => 203)) ), mints AS (   SELECT     DATE_TRUNC('week', block_timestamp) AS week,     SUM(mint_amount)*pow(10, -6) AS mints   FROM solana.defi.fact_token_mint_actions   WHERE mint = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'     AND succeeded   GROUP BY 1 ), burns AS (   SELECT     DATE_TRUNC('week', block_timestamp) AS week,     SUM(burn_amount)*pow(10, -6) AS burns   FROM solana.defi.fact_token_burn_actions   WHERE mint = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'     AND succeeded   GROUP BY 1 ), final_table AS (   SELECT     week,     COALESCE(mints, 0) - COALESCE(burns, 0) AS net_flow   FROM mints   FULL OUTER JOIN burns USING(week) ) SELECT   week,   COALESCE(net_flow, 0) AS net_flow,   SUM(net_flow) OVER (ORDER BY week) AS total_usdc_supply FROM week_series LEFT JOIN final_table USING(week) ORDER BY week DESC
7f56c3c8-ba7c-4dcc-ad18-e2d3d76497b0,evm,--WITH SELECT FROM WHERE 1=1   and tx_hash =    and contract_address =    and origin_from_address =    and origin_to_address =  -- hourly_prices as ( -- SELECT -- FROM ethereum.price.ez_prices_hourly -- WHERE 1=1 --   and token_address =  -- )
14c579c2-0e4f-4b88-aaf1-4b7660b928cb,JUP_alloc,SELECT   tiers AS "Tier",   wallets AS "Eligible wallets",   alloc AS "Allocation (in JUP tokens)",   ROUND(0.57 * alloc) AS "Current allocation value (USD)" FROM VALUES ('tier 1:', 2000, 100000), ('tier 2:', 10000, 20000), ('tier 3:', 50000, 3000), ('tier 4:', 150000, 1000), ('tier 5:', 743000, 200) AS t(tiers, wallets, alloc)
33bc7d03-62f1-45cd-aadb-c7c06ca8775d,solana,With pengy_swappers as ( SELECT   trader, --unique address swapping $PENGY   token_in,   token_out,   symbol_out,   amount_out_usd FROM crosschain.defi.ez_dex_swaps WHERE   token_in = '9YHZjCb14bB9XWZz6FZPTf5nek7kLeoGHmNNrgcxpump' --This is the CA for $PENGY tokens GROUP BY trader, token_in, token_out, symbol_out, amount_out_usd ORDER BY amount_out_usd ASC; ), subsequent_purchases AS ( SELECT   swaps.token_in AS purchased_token,   swaps.symbol_in AS purchased_symbol,   swaps.amount_in_usd AS purchase_value_usd FROM crosschain.defi.ez_dex_swaps AS swaps INNER JOIN pengy_swappers AS ps   ON swaps.trader = ps.trader WHERE swaps.token_out != '9YHZjCb14bB9XWZz6FZPTf5nek7kLeoGHmNNrgcxpump' -- Exclude $PENGY as an output ) SELECT    purchased_token,   purchased_symbol, SUM(purchase_value_usd) AS total_purchase_value_usd FROM subsequent_purchases GROUP BY purchased_token, purchased_symbol ORDER BY total_purchase_value_usd DESC;